{"/home/travis/build/npmtest/node-npmtest-later/test.js":"/* istanbul instrument in package npmtest_later */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-later/lib.npmtest_later.js":"/* istanbul instrument in package npmtest_later */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_later = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_later = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-later/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-later && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_later */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_later\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_later.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_later.rollup.js'] =\n            local.assetsDict['/assets.npmtest_later.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_later.__dirname + '/lib.npmtest_later.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/index.js":"var globals = [\"document\", \"window\", \"later\"],\n    globalValues = {};\n\nglobals.forEach(function(g) {\n  if (g in global) globalValues[g] = global[g];\n});\n\nrequire(process.env['LATER_COV'] ? \"./later-cov\" : \"./later\");\n\nmodule.exports = later;\n\nglobals.forEach(function(g) {\n  if (g in globalValues) global[g] = globalValues[g];\n  else delete global[g];\n});","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/later.js":"later = function() {\n  \"use strict\";\n  var later = {\n    version: \"1.2.0\"\n  };\n  if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(searchElement) {\n      \"use strict\";\n      if (this == null) {\n        throw new TypeError();\n      }\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (len === 0) {\n        return -1;\n      }\n      var n = 0;\n      if (arguments.length > 1) {\n        n = Number(arguments[1]);\n        if (n != n) {\n          n = 0;\n        } else if (n != 0 && n != Infinity && n != -Infinity) {\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\n        }\n      }\n      if (n >= len) {\n        return -1;\n      }\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n      for (;k < len; k++) {\n        if (k in t && t[k] === searchElement) {\n          return k;\n        }\n      }\n      return -1;\n    };\n  }\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g, \"\");\n    };\n  }\n  later.array = {};\n  later.array.sort = function(arr, zeroIsLast) {\n    arr.sort(function(a, b) {\n      return +a - +b;\n    });\n    if (zeroIsLast && arr[0] === 0) {\n      arr.push(arr.shift());\n    }\n  };\n  later.array.next = function(val, values, extent) {\n    var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;\n    for (var i = values.length - 1; i > -1; --i) {\n      cur = values[i];\n      if (cur === val) {\n        return cur;\n      }\n      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {\n        nextIdx = i;\n        continue;\n      }\n      break;\n    }\n    return values[nextIdx];\n  };\n  later.array.nextInvalid = function(val, values, extent) {\n    var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n    while (next === (values[i] || zeroVal)) {\n      next++;\n      if (next > max) {\n        next = min;\n      }\n      i++;\n      if (i === len) {\n        i = 0;\n      }\n      if (next === start) {\n        return undefined;\n      }\n    }\n    return next;\n  };\n  later.array.prev = function(val, values, extent) {\n    var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;\n    for (var i = 0; i < len; i++) {\n      cur = values[i];\n      if (cur === val) {\n        return cur;\n      }\n      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {\n        prevIdx = i;\n        continue;\n      }\n      break;\n    }\n    return values[prevIdx];\n  };\n  later.array.prevInvalid = function(val, values, extent) {\n    var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n    while (next === (values[i] || zeroVal)) {\n      next--;\n      if (next < min) {\n        next = max;\n      }\n      i--;\n      if (i === -1) {\n        i = len - 1;\n      }\n      if (next === start) {\n        return undefined;\n      }\n    }\n    return next;\n  };\n  later.day = later.D = {\n    name: \"day\",\n    range: 86400,\n    val: function(d) {\n      return d.D || (d.D = later.date.getDate.call(d));\n    },\n    isValid: function(d, val) {\n      return later.D.val(d) === (val || later.D.extent(d)[1]);\n    },\n    extent: function(d) {\n      if (d.DExtent) return d.DExtent;\n      var month = later.M.val(d), max = later.DAYS_IN_MONTH[month - 1];\n      if (month === 2 && later.dy.extent(d)[1] === 366) {\n        max = max + 1;\n      }\n      return d.DExtent = [ 1, max ];\n    },\n    start: function(d) {\n      return d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d)));\n    },\n    end: function(d) {\n      return d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d)));\n    },\n    next: function(d, val) {\n      val = val > later.D.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n      val = val > DMax ? 1 : val || DMax;\n      return later.date.next(later.Y.val(month), later.M.val(month), val);\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n      return later.date.prev(later.Y.val(month), later.M.val(month), val > DMax ? DMax : val || DMax);\n    }\n  };\n  later.dayOfWeekCount = later.dc = {\n    name: \"day of week count\",\n    range: 604800,\n    val: function(d) {\n      return d.dc || (d.dc = Math.floor((later.D.val(d) - 1) / 7) + 1);\n    },\n    isValid: function(d, val) {\n      return later.dc.val(d) === val || val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7;\n    },\n    extent: function(d) {\n      return d.dcExtent || (d.dcExtent = [ 1, Math.ceil(later.D.extent(d)[1] / 7) ]);\n    },\n    start: function(d) {\n      return d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, (later.dc.val(d) - 1) * 7 + 1 || 1)));\n    },\n    end: function(d) {\n      return d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));\n    },\n    next: function(d, val) {\n      val = val > later.dc.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n      val = val > dcMax ? 1 : val;\n      var next = later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n      if (next.getTime() <= d.getTime()) {\n        month = later.M.next(d, later.M.val(d) + 1);\n        return later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n      val = val > dcMax ? dcMax : val || dcMax;\n      return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), 1 + 7 * (val - 1)));\n    }\n  };\n  later.dayOfWeek = later.dw = later.d = {\n    name: \"day of week\",\n    range: 86400,\n    val: function(d) {\n      return d.dw || (d.dw = later.date.getDay.call(d) + 1);\n    },\n    isValid: function(d, val) {\n      return later.dw.val(d) === (val || 7);\n    },\n    extent: function() {\n      return [ 1, 7 ];\n    },\n    start: function(d) {\n      return later.D.start(d);\n    },\n    end: function(d) {\n      return later.D.end(d);\n    },\n    next: function(d, val) {\n      val = val > 7 ? 1 : val || 7;\n      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));\n    },\n    prev: function(d, val) {\n      val = val > 7 ? 7 : val || 7;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));\n    }\n  };\n  later.dayOfYear = later.dy = {\n    name: \"day of year\",\n    range: 86400,\n    val: function(d) {\n      return d.dy || (d.dy = Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));\n    },\n    isValid: function(d, val) {\n      return later.dy.val(d) === (val || later.dy.extent(d)[1]);\n    },\n    extent: function(d) {\n      var year = later.Y.val(d);\n      return d.dyExtent || (d.dyExtent = [ 1, year % 4 ? 365 : 366 ]);\n    },\n    start: function(d) {\n      return later.D.start(d);\n    },\n    end: function(d) {\n      return later.D.end(d);\n    },\n    next: function(d, val) {\n      val = val > later.dy.extent(d)[1] ? 1 : val;\n      var year = later.date.nextRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n      val = val > dyMax ? 1 : val || dyMax;\n      return later.date.next(later.Y.val(year), later.M.val(year), val);\n    },\n    prev: function(d, val) {\n      var year = later.date.prevRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n      val = val > dyMax ? dyMax : val || dyMax;\n      return later.date.prev(later.Y.val(year), later.M.val(year), val);\n    }\n  };\n  later.hour = later.h = {\n    name: \"hour\",\n    range: 3600,\n    val: function(d) {\n      return d.h || (d.h = later.date.getHour.call(d));\n    },\n    isValid: function(d, val) {\n      return later.h.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 23 ];\n    },\n    start: function(d) {\n      return d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n    },\n    end: function(d) {\n      return d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n    },\n    next: function(d, val) {\n      val = val > 23 ? 0 : val;\n      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.h.val(d) ? 1 : 0), val);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), val + 1);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 23 ? 23 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.h.val(d) ? -1 : 0), val);\n    }\n  };\n  later.minute = later.m = {\n    name: \"minute\",\n    range: 60,\n    val: function(d) {\n      return d.m || (d.m = later.date.getMin.call(d));\n    },\n    isValid: function(d, val) {\n      return later.m.val(d) === val;\n    },\n    extent: function(d) {\n      return [ 0, 59 ];\n    },\n    start: function(d) {\n      return d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n    },\n    end: function(d) {\n      return d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n    },\n    next: function(d, val) {\n      var m = later.m.val(d), s = later.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later.MIN - s * later.SEC);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = new Date(d.getTime() + (inc + 120) * later.MIN - s * later.SEC);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 59 ? 59 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d) + (val >= later.m.val(d) ? -1 : 0), val);\n    }\n  };\n  later.month = later.M = {\n    name: \"month\",\n    range: 2629740,\n    val: function(d) {\n      return d.M || (d.M = later.date.getMonth.call(d) + 1);\n    },\n    isValid: function(d, val) {\n      return later.M.val(d) === (val || 12);\n    },\n    extent: function() {\n      return [ 1, 12 ];\n    },\n    start: function(d) {\n      return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));\n    },\n    end: function(d) {\n      return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));\n    },\n    next: function(d, val) {\n      val = val > 12 ? 1 : val || 12;\n      return later.date.next(later.Y.val(d) + (val > later.M.val(d) ? 0 : 1), val);\n    },\n    prev: function(d, val) {\n      val = val > 12 ? 12 : val || 12;\n      return later.date.prev(later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0), val);\n    }\n  };\n  later.second = later.s = {\n    name: \"second\",\n    range: 1,\n    val: function(d) {\n      return d.s || (d.s = later.date.getSec.call(d));\n    },\n    isValid: function(d, val) {\n      return later.s.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 59 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      var s = later.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later.SEC);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = new Date(d.getTime() + (inc + 7200) * later.SEC);\n      }\n      return next;\n    },\n    prev: function(d, val, cache) {\n      val = val > 59 ? 59 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d) + (val >= later.s.val(d) ? -1 : 0), val);\n    }\n  };\n  later.time = later.t = {\n    name: \"time\",\n    range: 1,\n    val: function(d) {\n      return d.t || (d.t = later.h.val(d) * 3600 + later.m.val(d) * 60 + later.s.val(d));\n    },\n    isValid: function(d, val) {\n      return later.t.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 86399 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      val = val > 86399 ? 0 : val;\n      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.t.val(d) ? 1 : 0), 0, 0, val);\n      if (!later.date.isUTC && next.getTime() < d.getTime()) {\n        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), val + 7200);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 86399 ? 86399 : val;\n      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.t.val(d) ? -1 : 0), 0, 0, val);\n    }\n  };\n  later.weekOfMonth = later.wm = {\n    name: \"week of month\",\n    range: 604800,\n    val: function(d) {\n      return d.wm || (d.wm = (later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);\n    },\n    isValid: function(d, val) {\n      return later.wm.val(d) === (val || later.wm.extent(d)[1]);\n    },\n    extent: function(d) {\n      return d.wmExtent || (d.wmExtent = [ 1, (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7 ]);\n    },\n    start: function(d) {\n      return d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));\n    },\n    end: function(d) {\n      return d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));\n    },\n    next: function(d, val) {\n      val = val > later.wm.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n      val = val > wmMax ? 1 : val || wmMax;\n      return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2)));\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n      val = val > wmMax ? wmMax : val || wmMax;\n      return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2))));\n    }\n  };\n  later.weekOfYear = later.wy = {\n    name: \"week of year (ISO)\",\n    range: 604800,\n    val: function(d) {\n      if (d.wy) return d.wy;\n      var wThur = later.dw.next(later.wy.start(d), 5), YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur) - 1), 5);\n      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK);\n    },\n    isValid: function(d, val) {\n      return later.wy.val(d) === (val || later.wy.extent(d)[1]);\n    },\n    extent: function(d) {\n      if (d.wyExtent) return d.wyExtent;\n      var year = later.dw.next(later.wy.start(d), 5), dwFirst = later.dw.val(later.Y.start(year)), dwLast = later.dw.val(later.Y.end(year));\n      return d.wyExtent = [ 1, dwFirst === 5 || dwLast === 5 ? 53 : 52 ];\n    },\n    start: function(d) {\n      return d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)));\n    },\n    end: function(d) {\n      return d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)));\n    },\n    next: function(d, val) {\n      val = val > later.wy.extent(d)[1] ? 1 : val;\n      var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.nextRollover(wyThur, val, later.wy, later.Y);\n      if (later.wy.val(year) !== 1) {\n        year = later.dw.next(year, 2);\n      }\n      var wyMax = later.wy.extent(year)[1], wyStart = later.wy.start(year);\n      val = val > wyMax ? 1 : val || wyMax;\n      return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), later.D.val(wyStart) + 7 * (val - 1));\n    },\n    prev: function(d, val) {\n      var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.prevRollover(wyThur, val, later.wy, later.Y);\n      if (later.wy.val(year) !== 1) {\n        year = later.dw.next(year, 2);\n      }\n      var wyMax = later.wy.extent(year)[1], wyEnd = later.wy.end(year);\n      val = val > wyMax ? wyMax : val || wyMax;\n      return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), later.D.val(wyEnd) + 7 * (val - 1)));\n    }\n  };\n  later.year = later.Y = {\n    name: \"year\",\n    range: 31556900,\n    val: function(d) {\n      return d.Y || (d.Y = later.date.getYear.call(d));\n    },\n    isValid: function(d, val) {\n      return later.Y.val(d) === val;\n    },\n    extent: function() {\n      return [ 1970, 2099 ];\n    },\n    start: function(d) {\n      return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));\n    },\n    end: function(d) {\n      return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));\n    },\n    next: function(d, val) {\n      return val > later.Y.val(d) && val <= later.Y.extent()[1] ? later.date.next(val) : later.NEVER;\n    },\n    prev: function(d, val) {\n      return val < later.Y.val(d) && val >= later.Y.extent()[0] ? later.date.prev(val) : later.NEVER;\n    }\n  };\n  later.fullDate = later.fd = {\n    name: \"full date\",\n    range: 1,\n    val: function(d) {\n      return d.fd || (d.fd = d.getTime());\n    },\n    isValid: function(d, val) {\n      return later.fd.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 3250368e7 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      return later.fd.val(d) < val ? new Date(val) : later.NEVER;\n    },\n    prev: function(d, val) {\n      return later.fd.val(d) > val ? new Date(val) : later.NEVER;\n    }\n  };\n  later.modifier = {};\n  later.modifier.after = later.modifier.a = function(constraint, values) {\n    var value = values[0];\n    return {\n      name: \"after \" + constraint.name,\n      range: (constraint.extent(new Date())[1] - value) * constraint.range,\n      val: constraint.val,\n      isValid: function(d, val) {\n        return this.val(d) >= value;\n      },\n      extent: constraint.extent,\n      start: constraint.start,\n      end: constraint.end,\n      next: function(startDate, val) {\n        if (val != value) val = constraint.extent(startDate)[0];\n        return constraint.next(startDate, val);\n      },\n      prev: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[1] : value - 1;\n        return constraint.prev(startDate, val);\n      }\n    };\n  };\n  later.modifier.before = later.modifier.b = function(constraint, values) {\n    var value = values[values.length - 1];\n    return {\n      name: \"before \" + constraint.name,\n      range: constraint.range * (value - 1),\n      val: constraint.val,\n      isValid: function(d, val) {\n        return this.val(d) < value;\n      },\n      extent: constraint.extent,\n      start: constraint.start,\n      end: constraint.end,\n      next: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[0] : value;\n        return constraint.next(startDate, val);\n      },\n      prev: function(startDate, val) {\n        val = val === value ? value - 1 : constraint.extent(startDate)[1];\n        return constraint.prev(startDate, val);\n      }\n    };\n  };\n  later.compile = function(schedDef) {\n    var constraints = [], constraintsLen = 0, tickConstraint;\n    for (var key in schedDef) {\n      var nameParts = key.split(\"_\"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later.modifier[mod](later[name], vals) : later[name];\n      constraints.push({\n        constraint: constraint,\n        vals: vals\n      });\n      constraintsLen++;\n    }\n    constraints.sort(function(a, b) {\n      var ra = a.constraint.range, rb = b.constraint.range;\n      return rb < ra ? -1 : rb > ra ? 1 : 0;\n    });\n    tickConstraint = constraints[constraintsLen - 1].constraint;\n    function compareFn(dir) {\n      return dir === \"next\" ? function(a, b) {\n        return a.getTime() > b.getTime();\n      } : function(a, b) {\n        return b.getTime() > a.getTime();\n      };\n    }\n    return {\n      start: function(dir, startDate) {\n        var next = startDate, nextVal = later.array[dir], maxAttempts = 1e3, done;\n        while (maxAttempts-- && !done && next) {\n          done = true;\n          for (var i = 0; i < constraintsLen; i++) {\n            var constraint = constraints[i].constraint, curVal = constraint.val(next), extent = constraint.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);\n            if (!constraint.isValid(next, newVal)) {\n              next = constraint[dir](next, newVal);\n              done = false;\n              break;\n            }\n          }\n        }\n        if (next !== later.NEVER) {\n          next = dir === \"next\" ? tickConstraint.start(next) : tickConstraint.end(next);\n        }\n        return next;\n      },\n      end: function(dir, startDate) {\n        var result, nextVal = later.array[dir + \"Invalid\"], compare = compareFn(dir);\n        for (var i = constraintsLen - 1; i >= 0; i--) {\n          var constraint = constraints[i].constraint, curVal = constraint.val(startDate), extent = constraint.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;\n          if (newVal !== undefined) {\n            next = constraint[dir](startDate, newVal);\n            if (next && (!result || compare(result, next))) {\n              result = next;\n            }\n          }\n        }\n        return result;\n      },\n      tick: function(dir, date) {\n        return new Date(dir === \"next\" ? tickConstraint.end(date).getTime() + later.SEC : tickConstraint.start(date).getTime() - later.SEC);\n      },\n      tickStart: function(date) {\n        return tickConstraint.start(date);\n      }\n    };\n  };\n  later.schedule = function(sched) {\n    if (!sched) throw new Error(\"Missing schedule definition.\");\n    if (!sched.schedules) throw new Error(\"Definition must include at least one schedule.\");\n    var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;\n    for (var i = 0; i < schedulesLen; i++) {\n      schedules.push(later.compile(sched.schedules[i]));\n    }\n    for (var j = 0; j < exceptionsLen; j++) {\n      exceptions.push(later.compile(sched.exceptions[j]));\n    }\n    function getInstances(dir, count, startDate, endDate, isRange) {\n      var compare = compareFn(dir), loopCount = count, maxAttempts = 1e3, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === \"next\", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;\n      startDate = startDate ? new Date(startDate) : new Date();\n      if (!startDate || !startDate.getTime()) throw new Error(\"Invalid start date.\");\n      setNextStarts(dir, schedules, schedStarts, startDate);\n      setRangeStarts(dir, exceptions, exceptStarts, startDate);\n      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {\n        if (endDate && compare(next, endDate)) {\n          break;\n        }\n        if (exceptionsLen) {\n          updateRangeStarts(dir, exceptions, exceptStarts, next);\n          if (end = calcRangeOverlap(dir, exceptStarts, next)) {\n            updateNextStarts(dir, schedules, schedStarts, end);\n            continue;\n          }\n        }\n        if (isRange) {\n          var maxEndDate = calcMaxEndDate(exceptStarts, compare);\n          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);\n          var r = isForward ? [ new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined ] : [ end ? new Date(endDate ? Math.max(endDate, end.getTime() + later.SEC) : end.getTime() + later.SEC) : undefined, new Date(Math.min(startDate, next.getTime() + later.SEC)) ];\n          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {\n            lastResult[rEnd] = r[rEnd];\n            loopCount++;\n          } else {\n            lastResult = r;\n            results.push(lastResult);\n          }\n          if (!end) break;\n          updateNextStarts(dir, schedules, schedStarts, end);\n        } else {\n          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));\n          tickStarts(dir, schedules, schedStarts, next);\n        }\n        loopCount--;\n      }\n      for (var i = 0, len = results.length; i < len; i++) {\n        var result = results[i];\n        results[i] = Object.prototype.toString.call(result) === \"[object Array]\" ? [ cleanDate(result[0]), cleanDate(result[1]) ] : cleanDate(result);\n      }\n      return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;\n    }\n    function cleanDate(d) {\n      if (d instanceof Date && !isNaN(d.valueOf())) {\n        return new Date(d);\n      }\n      return undefined;\n    }\n    function setNextStarts(dir, schedArr, startsArr, startDate) {\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        startsArr[i] = schedArr[i].start(dir, startDate);\n      }\n    }\n    function updateNextStarts(dir, schedArr, startsArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (startsArr[i] && !compare(startsArr[i], startDate)) {\n          startsArr[i] = schedArr[i].start(dir, startDate);\n        }\n      }\n    }\n    function setRangeStarts(dir, schedArr, rangesArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        var nextStart = schedArr[i].start(dir, startDate);\n        if (!nextStart) {\n          rangesArr[i] = later.NEVER;\n        } else {\n          rangesArr[i] = [ nextStart, schedArr[i].end(dir, nextStart) ];\n        }\n      }\n    }\n    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (rangesArr[i] && !compare(rangesArr[i][0], startDate)) {\n          var nextStart = schedArr[i].start(dir, startDate);\n          if (!nextStart) {\n            rangesArr[i] = later.NEVER;\n          } else {\n            rangesArr[i] = [ nextStart, schedArr[i].end(dir, nextStart) ];\n          }\n        }\n      }\n    }\n    function tickStarts(dir, schedArr, startsArr, startDate) {\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n          startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));\n        }\n      }\n    }\n    function getStart(schedArr, startsArr, startDate, minEndDate) {\n      var result;\n      for (var i = 0, len = startsArr.length; i < len; i++) {\n        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n          var start = schedArr[i].tickStart(startDate);\n          if (minEndDate && start < minEndDate) {\n            return minEndDate;\n          }\n          if (!result || start > result) {\n            result = start;\n          }\n        }\n      }\n      return result;\n    }\n    function calcRangeOverlap(dir, rangesArr, startDate) {\n      var compare = compareFn(dir), result;\n      for (var i = 0, len = rangesArr.length; i < len; i++) {\n        var range = rangesArr[i];\n        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {\n          if (!result || compare(range[1], result)) {\n            result = range[1];\n          }\n        }\n      }\n      return result;\n    }\n    function calcMaxEndDate(exceptsArr, compare) {\n      var result;\n      for (var i = 0, len = exceptsArr.length; i < len; i++) {\n        if (exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {\n          result = exceptsArr[i][0];\n        }\n      }\n      return result;\n    }\n    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {\n      var compare = compareFn(dir), result;\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        var start = startsArr[i];\n        if (start && start.getTime() === startDate.getTime()) {\n          var end = schedArr[i].end(dir, start);\n          if (maxEndDate && (!end || compare(end, maxEndDate))) {\n            return maxEndDate;\n          }\n          if (!result || compare(end, result)) {\n            result = end;\n          }\n        }\n      }\n      return result;\n    }\n    function compareFn(dir) {\n      return dir === \"next\" ? function(a, b) {\n        return !b || a.getTime() > b.getTime();\n      } : function(a, b) {\n        return !a || b.getTime() > a.getTime();\n      };\n    }\n    function findNext(arr, compare) {\n      var next = arr[0];\n      for (var i = 1, len = arr.length; i < len; i++) {\n        if (arr[i] && compare(next, arr[i])) {\n          next = arr[i];\n        }\n      }\n      return next;\n    }\n    return {\n      isValid: function(d) {\n        return getInstances(\"next\", 1, d, d) !== later.NEVER;\n      },\n      next: function(count, startDate, endDate) {\n        return getInstances(\"next\", count || 1, startDate, endDate);\n      },\n      prev: function(count, startDate, endDate) {\n        return getInstances(\"prev\", count || 1, startDate, endDate);\n      },\n      nextRange: function(count, startDate, endDate) {\n        return getInstances(\"next\", count || 1, startDate, endDate, true);\n      },\n      prevRange: function(count, startDate, endDate) {\n        return getInstances(\"prev\", count || 1, startDate, endDate, true);\n      }\n    };\n  };\n  later.setTimeout = function(fn, sched) {\n    var s = later.schedule(sched), t;\n    if (fn) {\n      scheduleTimeout();\n    }\n    function scheduleTimeout() {\n      var now = Date.now(), next = s.next(2, now);\n      if (!next[0]) {\n        t = undefined;\n        return;\n      }\n      var diff = next[0].getTime() - now;\n      if (diff < 1e3) {\n        diff = next[1] ? next[1].getTime() - now : 1e3;\n      }\n      if (diff < 2147483647) {\n        t = setTimeout(fn, diff);\n      } else {\n        t = setTimeout(scheduleTimeout, 2147483647);\n      }\n    }\n    return {\n      isDone: function() {\n        return !t;\n      },\n      clear: function() {\n        clearTimeout(t);\n      }\n    };\n  };\n  later.setInterval = function(fn, sched) {\n    if (!fn) {\n      return;\n    }\n    var t = later.setTimeout(scheduleTimeout, sched), done = t.isDone();\n    function scheduleTimeout() {\n      if (!done) {\n        fn();\n        t = later.setTimeout(scheduleTimeout, sched);\n      }\n    }\n    return {\n      isDone: function() {\n        return t.isDone();\n      },\n      clear: function() {\n        done = true;\n        t.clear();\n      }\n    };\n  };\n  later.date = {};\n  later.date.timezone = function(useLocalTime) {\n    later.date.build = useLocalTime ? function(Y, M, D, h, m, s) {\n      return new Date(Y, M, D, h, m, s);\n    } : function(Y, M, D, h, m, s) {\n      return new Date(Date.UTC(Y, M, D, h, m, s));\n    };\n    var get = useLocalTime ? \"get\" : \"getUTC\", d = Date.prototype;\n    later.date.getYear = d[get + \"FullYear\"];\n    later.date.getMonth = d[get + \"Month\"];\n    later.date.getDate = d[get + \"Date\"];\n    later.date.getDay = d[get + \"Day\"];\n    later.date.getHour = d[get + \"Hours\"];\n    later.date.getMin = d[get + \"Minutes\"];\n    later.date.getSec = d[get + \"Seconds\"];\n    later.date.isUTC = !useLocalTime;\n  };\n  later.date.UTC = function() {\n    later.date.timezone(false);\n  };\n  later.date.localTime = function() {\n    later.date.timezone(true);\n  };\n  later.date.UTC();\n  later.SEC = 1e3;\n  later.MIN = later.SEC * 60;\n  later.HOUR = later.MIN * 60;\n  later.DAY = later.HOUR * 24;\n  later.WEEK = later.DAY * 7;\n  later.DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n  later.NEVER = 0;\n  later.date.next = function(Y, M, D, h, m, s) {\n    return later.date.build(Y, M !== undefined ? M - 1 : 0, D !== undefined ? D : 1, h || 0, m || 0, s || 0);\n  };\n  later.date.nextRollover = function(d, val, constraint, period) {\n    var cur = constraint.val(d), max = constraint.extent(d)[1];\n    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later.SEC) : period.start(d);\n  };\n  later.date.prev = function(Y, M, D, h, m, s) {\n    var len = arguments.length;\n    M = len < 2 ? 11 : M - 1;\n    D = len < 3 ? later.D.extent(later.date.next(Y, M + 1))[1] : D;\n    h = len < 4 ? 23 : h;\n    m = len < 5 ? 59 : m;\n    s = len < 6 ? 59 : s;\n    return later.date.build(Y, M, D, h, m, s);\n  };\n  later.date.prevRollover = function(d, val, constraint, period) {\n    var cur = constraint.val(d);\n    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);\n  };\n  later.parse = {};\n  later.parse.cron = function(expr, hasSeconds) {\n    var NAMES = {\n      JAN: 1,\n      FEB: 2,\n      MAR: 3,\n      APR: 4,\n      MAY: 5,\n      JUN: 6,\n      JUL: 7,\n      AUG: 8,\n      SEP: 9,\n      OCT: 10,\n      NOV: 11,\n      DEC: 12,\n      SUN: 1,\n      MON: 2,\n      TUE: 3,\n      WED: 4,\n      THU: 5,\n      FRI: 6,\n      SAT: 7\n    };\n    var REPLACEMENTS = {\n      \"* * * * * *\": \"0/1 * * * * *\",\n      \"@YEARLY\": \"0 0 1 1 *\",\n      \"@ANNUALLY\": \"0 0 1 1 *\",\n      \"@MONTHLY\": \"0 0 1 * *\",\n      \"@WEEKLY\": \"0 0 * * 0\",\n      \"@DAILY\": \"0 0 * * *\",\n      \"@HOURLY\": \"0 * * * *\"\n    };\n    var FIELDS = {\n      s: [ 0, 0, 59 ],\n      m: [ 1, 0, 59 ],\n      h: [ 2, 0, 23 ],\n      D: [ 3, 1, 31 ],\n      M: [ 4, 1, 12 ],\n      Y: [ 6, 1970, 2099 ],\n      d: [ 5, 1, 7, 1 ]\n    };\n    function getValue(value, offset, max) {\n      return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);\n    }\n    function cloneSchedule(sched) {\n      var clone = {}, field;\n      for (field in sched) {\n        if (field !== \"dc\" && field !== \"d\") {\n          clone[field] = sched[field].slice(0);\n        }\n      }\n      return clone;\n    }\n    function add(sched, name, min, max, inc) {\n      var i = min;\n      if (!sched[name]) {\n        sched[name] = [];\n      }\n      while (i <= max) {\n        if (sched[name].indexOf(i) < 0) {\n          sched[name].push(i);\n        }\n        i += inc || 1;\n      }\n      sched[name].sort(function(a, b) {\n        return a - b;\n      });\n    }\n    function addHash(schedules, curSched, value, hash) {\n      if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {\n        schedules.push(cloneSchedule(curSched));\n        curSched = schedules[schedules.length - 1];\n      }\n      add(curSched, \"d\", value, value);\n      add(curSched, \"dc\", hash, hash);\n    }\n    function addWeekday(s, curSched, value) {\n      var except1 = {}, except2 = {};\n      if (value === 1) {\n        add(curSched, \"D\", 1, 3);\n        add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n        add(except1, \"D\", 2, 2);\n        add(except1, \"d\", NAMES.TUE, NAMES.FRI);\n        add(except2, \"D\", 3, 3);\n        add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n      } else {\n        add(curSched, \"D\", value - 1, value + 1);\n        add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n        add(except1, \"D\", value - 1, value - 1);\n        add(except1, \"d\", NAMES.MON, NAMES.THU);\n        add(except2, \"D\", value + 1, value + 1);\n        add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n      }\n      s.exceptions.push(except1);\n      s.exceptions.push(except2);\n    }\n    function addRange(item, curSched, name, min, max, offset) {\n      var incSplit = item.split(\"/\"), inc = +incSplit[1], range = incSplit[0];\n      if (range !== \"*\" && range !== \"0\") {\n        var rangeSplit = range.split(\"-\");\n        min = getValue(rangeSplit[0], offset, max);\n        max = getValue(rangeSplit[1], offset, max) || max;\n      }\n      add(curSched, name, min, max, inc);\n    }\n    function parse(item, s, name, min, max, offset) {\n      var value, split, schedules = s.schedules, curSched = schedules[schedules.length - 1];\n      if (item === \"L\") {\n        item = min - 1;\n      }\n      if ((value = getValue(item, offset, max)) !== null) {\n        add(curSched, name, value, value);\n      } else if ((value = getValue(item.replace(\"W\", \"\"), offset, max)) !== null) {\n        addWeekday(s, curSched, value);\n      } else if ((value = getValue(item.replace(\"L\", \"\"), offset, max)) !== null) {\n        addHash(schedules, curSched, value, min - 1);\n      } else if ((split = item.split(\"#\")).length === 2) {\n        value = getValue(split[0], offset, max);\n        addHash(schedules, curSched, value, getValue(split[1]));\n      } else {\n        addRange(item, curSched, name, min, max, offset);\n      }\n    }\n    function isHash(item) {\n      return item.indexOf(\"#\") > -1 || item.indexOf(\"L\") > 0;\n    }\n    function itemSorter(a, b) {\n      return isHash(a) && !isHash(b) ? 1 : a - b;\n    }\n    function parseExpr(expr) {\n      var schedule = {\n        schedules: [ {} ],\n        exceptions: []\n      }, components = expr.replace(/(\\s)+/g, \" \").split(\" \"), field, f, component, items;\n      for (field in FIELDS) {\n        f = FIELDS[field];\n        component = components[f[0]];\n        if (component && component !== \"*\" && component !== \"?\") {\n          items = component.split(\",\").sort(itemSorter);\n          var i, length = items.length;\n          for (i = 0; i < length; i++) {\n            parse(items[i], schedule, field, f[1], f[2], f[3]);\n          }\n        }\n      }\n      return schedule;\n    }\n    function prepareExpr(expr) {\n      var prepared = expr.toUpperCase();\n      return REPLACEMENTS[prepared] || prepared;\n    }\n    var e = prepareExpr(expr);\n    return parseExpr(hasSeconds ? e : \"0 \" + e);\n  };\n  later.parse.recur = function() {\n    var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every, modifier, applyMin, applyMax, i, last;\n    function add(name, min, max) {\n      name = modifier ? name + \"_\" + modifier : name;\n      if (!cur) {\n        curArr.push({});\n        cur = curArr[0];\n      }\n      if (!cur[name]) {\n        cur[name] = [];\n      }\n      curName = cur[name];\n      if (every) {\n        values = [];\n        for (i = min; i <= max; i += every) {\n          values.push(i);\n        }\n        last = {\n          n: name,\n          x: every,\n          c: curName.length,\n          m: max\n        };\n      }\n      values = applyMin ? [ min ] : applyMax ? [ max ] : values;\n      var length = values.length;\n      for (i = 0; i < length; i += 1) {\n        var val = values[i];\n        if (curName.indexOf(val) < 0) {\n          curName.push(val);\n        }\n      }\n      values = every = modifier = applyMin = applyMax = 0;\n    }\n    return {\n      schedules: schedules,\n      exceptions: exceptions,\n      on: function() {\n        values = arguments[0] instanceof Array ? arguments[0] : arguments;\n        return this;\n      },\n      every: function(x) {\n        every = x || 1;\n        return this;\n      },\n      after: function(x) {\n        modifier = \"a\";\n        values = [ x ];\n        return this;\n      },\n      before: function(x) {\n        modifier = \"b\";\n        values = [ x ];\n        return this;\n      },\n      first: function() {\n        applyMin = 1;\n        return this;\n      },\n      last: function() {\n        applyMax = 1;\n        return this;\n      },\n      time: function() {\n        for (var i = 0, len = values.length; i < len; i++) {\n          var split = values[i].split(\":\");\n          if (split.length < 3) split.push(0);\n          values[i] = +split[0] * 3600 + +split[1] * 60 + +split[2];\n        }\n        add(\"t\");\n        return this;\n      },\n      second: function() {\n        add(\"s\", 0, 59);\n        return this;\n      },\n      minute: function() {\n        add(\"m\", 0, 59);\n        return this;\n      },\n      hour: function() {\n        add(\"h\", 0, 23);\n        return this;\n      },\n      dayOfMonth: function() {\n        add(\"D\", 1, applyMax ? 0 : 31);\n        return this;\n      },\n      dayOfWeek: function() {\n        add(\"d\", 1, 7);\n        return this;\n      },\n      onWeekend: function() {\n        values = [ 1, 7 ];\n        return this.dayOfWeek();\n      },\n      onWeekday: function() {\n        values = [ 2, 3, 4, 5, 6 ];\n        return this.dayOfWeek();\n      },\n      dayOfWeekCount: function() {\n        add(\"dc\", 1, applyMax ? 0 : 5);\n        return this;\n      },\n      dayOfYear: function() {\n        add(\"dy\", 1, applyMax ? 0 : 366);\n        return this;\n      },\n      weekOfMonth: function() {\n        add(\"wm\", 1, applyMax ? 0 : 5);\n        return this;\n      },\n      weekOfYear: function() {\n        add(\"wy\", 1, applyMax ? 0 : 53);\n        return this;\n      },\n      month: function() {\n        add(\"M\", 1, 12);\n        return this;\n      },\n      year: function() {\n        add(\"Y\", 1970, 2450);\n        return this;\n      },\n      fullDate: function() {\n        for (var i = 0, len = values.length; i < len; i++) {\n          values[i] = values[i].getTime();\n        }\n        add(\"fd\");\n        return this;\n      },\n      customModifier: function(id, vals) {\n        var custom = later.modifier[id];\n        if (!custom) throw new Error(\"Custom modifier \" + id + \" not recognized!\");\n        modifier = id;\n        values = arguments[1] instanceof Array ? arguments[1] : [ arguments[1] ];\n        return this;\n      },\n      customPeriod: function(id) {\n        var custom = later[id];\n        if (!custom) throw new Error(\"Custom time period \" + id + \" not recognized!\");\n        add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);\n        return this;\n      },\n      startingOn: function(start) {\n        return this.between(start, last.m);\n      },\n      between: function(start, end) {\n        cur[last.n] = cur[last.n].splice(0, last.c);\n        every = last.x;\n        add(last.n, start, end);\n        return this;\n      },\n      and: function() {\n        cur = curArr[curArr.push({}) - 1];\n        return this;\n      },\n      except: function() {\n        curArr = exceptions;\n        cur = null;\n        return this;\n      }\n    };\n  };\n  later.parse.text = function(str) {\n    var recur = later.parse.recur, pos = 0, input = \"\", error;\n    var TOKENTYPES = {\n      eof: /^$/,\n      rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,\n      time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,\n      dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,\n      monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,\n      yearIndex: /^(\\d\\d\\d\\d)\\b/,\n      every: /^every\\b/,\n      after: /^after\\b/,\n      before: /^before\\b/,\n      second: /^(s|sec(ond)?(s)?)\\b/,\n      minute: /^(m|min(ute)?(s)?)\\b/,\n      hour: /^(h|hour(s)?)\\b/,\n      day: /^(day(s)?( of the month)?)\\b/,\n      dayInstance: /^day instance\\b/,\n      dayOfWeek: /^day(s)? of the week\\b/,\n      dayOfYear: /^day(s)? of the year\\b/,\n      weekOfYear: /^week(s)?( of the year)?\\b/,\n      weekOfMonth: /^week(s)? of the month\\b/,\n      weekday: /^weekday\\b/,\n      weekend: /^weekend\\b/,\n      month: /^month(s)?\\b/,\n      year: /^year(s)?\\b/,\n      between: /^between (the)?\\b/,\n      start: /^(start(ing)? (at|on( the)?)?)\\b/,\n      at: /^(at|@)\\b/,\n      and: /^(,|and\\b)/,\n      except: /^(except\\b)/,\n      also: /(also)\\b/,\n      first: /^(first)\\b/,\n      last: /^last\\b/,\n      \"in\": /^in\\b/,\n      of: /^of\\b/,\n      onthe: /^on the\\b/,\n      on: /^on\\b/,\n      through: /(-|^(to|through)\\b)/\n    };\n    var NAMES = {\n      jan: 1,\n      feb: 2,\n      mar: 3,\n      apr: 4,\n      may: 5,\n      jun: 6,\n      jul: 7,\n      aug: 8,\n      sep: 9,\n      oct: 10,\n      nov: 11,\n      dec: 12,\n      sun: 1,\n      mon: 2,\n      tue: 3,\n      wed: 4,\n      thu: 5,\n      fri: 6,\n      sat: 7,\n      \"1st\": 1,\n      fir: 1,\n      \"2nd\": 2,\n      sec: 2,\n      \"3rd\": 3,\n      thi: 3,\n      \"4th\": 4,\n      \"for\": 4\n    };\n    function t(start, end, text, type) {\n      return {\n        startPos: start,\n        endPos: end,\n        text: text,\n        type: type\n      };\n    }\n    function peek(expected) {\n      var scanTokens = expected instanceof Array ? expected : [ expected ], whiteSpace = /\\s+/, token, curInput, m, scanToken, start, len;\n      scanTokens.push(whiteSpace);\n      start = pos;\n      while (!token || token.type === whiteSpace) {\n        len = -1;\n        curInput = input.substring(start);\n        token = t(start, start, input.split(whiteSpace)[0]);\n        var i, length = scanTokens.length;\n        for (i = 0; i < length; i++) {\n          scanToken = scanTokens[i];\n          m = scanToken.exec(curInput);\n          if (m && m.index === 0 && m[0].length > len) {\n            len = m[0].length;\n            token = t(start, start + len, curInput.substring(0, len), scanToken);\n          }\n        }\n        if (token.type === whiteSpace) {\n          start = token.endPos;\n        }\n      }\n      return token;\n    }\n    function scan(expectedToken) {\n      var token = peek(expectedToken);\n      pos = token.endPos;\n      return token;\n    }\n    function parseThroughExpr(tokenType) {\n      var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];\n      for (var i = start; i <= end; i++) {\n        nums.push(i);\n      }\n      return nums;\n    }\n    function parseRanges(tokenType) {\n      var nums = parseThroughExpr(tokenType);\n      while (checkAndParse(TOKENTYPES.and)) {\n        nums = nums.concat(parseThroughExpr(tokenType));\n      }\n      return nums;\n    }\n    function parseEvery(r) {\n      var num, period, start, end;\n      if (checkAndParse(TOKENTYPES.weekend)) {\n        r.on(NAMES.sun, NAMES.sat).dayOfWeek();\n      } else if (checkAndParse(TOKENTYPES.weekday)) {\n        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();\n      } else {\n        num = parseTokenValue(TOKENTYPES.rank);\n        r.every(num);\n        period = parseTimePeriod(r);\n        if (checkAndParse(TOKENTYPES.start)) {\n          num = parseTokenValue(TOKENTYPES.rank);\n          r.startingOn(num);\n          parseToken(period.type);\n        } else if (checkAndParse(TOKENTYPES.between)) {\n          start = parseTokenValue(TOKENTYPES.rank);\n          if (checkAndParse(TOKENTYPES.and)) {\n            end = parseTokenValue(TOKENTYPES.rank);\n            r.between(start, end);\n          }\n        }\n      }\n    }\n    function parseOnThe(r) {\n      if (checkAndParse(TOKENTYPES.first)) {\n        r.first();\n      } else if (checkAndParse(TOKENTYPES.last)) {\n        r.last();\n      } else {\n        r.on(parseRanges(TOKENTYPES.rank));\n      }\n      parseTimePeriod(r);\n    }\n    function parseScheduleExpr(str) {\n      pos = 0;\n      input = str;\n      error = -1;\n      var r = recur();\n      while (pos < input.length && error < 0) {\n        var token = parseToken([ TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also ]);\n        switch (token.type) {\n         case TOKENTYPES.every:\n          parseEvery(r);\n          break;\n\n         case TOKENTYPES.after:\n          if (peek(TOKENTYPES.time).type !== undefined) {\n            r.after(parseTokenValue(TOKENTYPES.time));\n            r.time();\n          } else {\n            r.after(parseTokenValue(TOKENTYPES.rank));\n            parseTimePeriod(r);\n          }\n          break;\n\n         case TOKENTYPES.before:\n          if (peek(TOKENTYPES.time).type !== undefined) {\n            r.before(parseTokenValue(TOKENTYPES.time));\n            r.time();\n          } else {\n            r.before(parseTokenValue(TOKENTYPES.rank));\n            parseTimePeriod(r);\n          }\n          break;\n\n         case TOKENTYPES.onthe:\n          parseOnThe(r);\n          break;\n\n         case TOKENTYPES.on:\n          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();\n          break;\n\n         case TOKENTYPES.of:\n          r.on(parseRanges(TOKENTYPES.monthName)).month();\n          break;\n\n         case TOKENTYPES[\"in\"]:\n          r.on(parseRanges(TOKENTYPES.yearIndex)).year();\n          break;\n\n         case TOKENTYPES.at:\n          r.on(parseTokenValue(TOKENTYPES.time)).time();\n          while (checkAndParse(TOKENTYPES.and)) {\n            r.on(parseTokenValue(TOKENTYPES.time)).time();\n          }\n          break;\n\n         case TOKENTYPES.and:\n          break;\n\n         case TOKENTYPES.also:\n          r.and();\n          break;\n\n         case TOKENTYPES.except:\n          r.except();\n          break;\n\n         default:\n          error = pos;\n        }\n      }\n      return {\n        schedules: r.schedules,\n        exceptions: r.exceptions,\n        error: error\n      };\n    }\n    function parseTimePeriod(r) {\n      var timePeriod = parseToken([ TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear ]);\n      switch (timePeriod.type) {\n       case TOKENTYPES.second:\n        r.second();\n        break;\n\n       case TOKENTYPES.minute:\n        r.minute();\n        break;\n\n       case TOKENTYPES.hour:\n        r.hour();\n        break;\n\n       case TOKENTYPES.dayOfYear:\n        r.dayOfYear();\n        break;\n\n       case TOKENTYPES.dayOfWeek:\n        r.dayOfWeek();\n        break;\n\n       case TOKENTYPES.dayInstance:\n        r.dayOfWeekCount();\n        break;\n\n       case TOKENTYPES.day:\n        r.dayOfMonth();\n        break;\n\n       case TOKENTYPES.weekOfMonth:\n        r.weekOfMonth();\n        break;\n\n       case TOKENTYPES.weekOfYear:\n        r.weekOfYear();\n        break;\n\n       case TOKENTYPES.month:\n        r.month();\n        break;\n\n       case TOKENTYPES.year:\n        r.year();\n        break;\n\n       default:\n        error = pos;\n      }\n      return timePeriod;\n    }\n    function checkAndParse(tokenType) {\n      var found = peek(tokenType).type === tokenType;\n      if (found) {\n        scan(tokenType);\n      }\n      return found;\n    }\n    function parseToken(tokenType) {\n      var t = scan(tokenType);\n      if (t.type) {\n        t.text = convertString(t.text, tokenType);\n      } else {\n        error = pos;\n      }\n      return t;\n    }\n    function parseTokenValue(tokenType) {\n      return parseToken(tokenType).text;\n    }\n    function convertString(str, tokenType) {\n      var output = str;\n      switch (tokenType) {\n       case TOKENTYPES.time:\n        var parts = str.split(/(:|am|pm)/), hour = parts[3] === \"pm\" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min = parts[2].trim();\n        output = (hour.length === 1 ? \"0\" : \"\") + hour + \":\" + min;\n        break;\n\n       case TOKENTYPES.rank:\n        output = parseInt(/^\\d+/.exec(str)[0], 10);\n        break;\n\n       case TOKENTYPES.monthName:\n       case TOKENTYPES.dayName:\n        output = NAMES[str.substring(0, 3)];\n        break;\n      }\n      return output;\n    }\n    return parseScheduleExpr(str.toLowerCase());\n  };\n  return later;\n}();","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/index-browserify.js":"require(\"./later\");\nmodule.exports = later;","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/later-core.js":"later = function() {\n  \"use strict\";\n  var later = {\n    version: \"1.2.0\"\n  };\n  if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(searchElement) {\n      \"use strict\";\n      if (this == null) {\n        throw new TypeError();\n      }\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (len === 0) {\n        return -1;\n      }\n      var n = 0;\n      if (arguments.length > 1) {\n        n = Number(arguments[1]);\n        if (n != n) {\n          n = 0;\n        } else if (n != 0 && n != Infinity && n != -Infinity) {\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\n        }\n      }\n      if (n >= len) {\n        return -1;\n      }\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n      for (;k < len; k++) {\n        if (k in t && t[k] === searchElement) {\n          return k;\n        }\n      }\n      return -1;\n    };\n  }\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g, \"\");\n    };\n  }\n  later.array = {};\n  later.array.sort = function(arr, zeroIsLast) {\n    arr.sort(function(a, b) {\n      return +a - +b;\n    });\n    if (zeroIsLast && arr[0] === 0) {\n      arr.push(arr.shift());\n    }\n  };\n  later.array.next = function(val, values, extent) {\n    var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;\n    for (var i = values.length - 1; i > -1; --i) {\n      cur = values[i];\n      if (cur === val) {\n        return cur;\n      }\n      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {\n        nextIdx = i;\n        continue;\n      }\n      break;\n    }\n    return values[nextIdx];\n  };\n  later.array.nextInvalid = function(val, values, extent) {\n    var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n    while (next === (values[i] || zeroVal)) {\n      next++;\n      if (next > max) {\n        next = min;\n      }\n      i++;\n      if (i === len) {\n        i = 0;\n      }\n      if (next === start) {\n        return undefined;\n      }\n    }\n    return next;\n  };\n  later.array.prev = function(val, values, extent) {\n    var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;\n    for (var i = 0; i < len; i++) {\n      cur = values[i];\n      if (cur === val) {\n        return cur;\n      }\n      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {\n        prevIdx = i;\n        continue;\n      }\n      break;\n    }\n    return values[prevIdx];\n  };\n  later.array.prevInvalid = function(val, values, extent) {\n    var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n    while (next === (values[i] || zeroVal)) {\n      next--;\n      if (next < min) {\n        next = max;\n      }\n      i--;\n      if (i === -1) {\n        i = len - 1;\n      }\n      if (next === start) {\n        return undefined;\n      }\n    }\n    return next;\n  };\n  later.day = later.D = {\n    name: \"day\",\n    range: 86400,\n    val: function(d) {\n      return d.D || (d.D = later.date.getDate.call(d));\n    },\n    isValid: function(d, val) {\n      return later.D.val(d) === (val || later.D.extent(d)[1]);\n    },\n    extent: function(d) {\n      if (d.DExtent) return d.DExtent;\n      var month = later.M.val(d), max = later.DAYS_IN_MONTH[month - 1];\n      if (month === 2 && later.dy.extent(d)[1] === 366) {\n        max = max + 1;\n      }\n      return d.DExtent = [ 1, max ];\n    },\n    start: function(d) {\n      return d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d)));\n    },\n    end: function(d) {\n      return d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d)));\n    },\n    next: function(d, val) {\n      val = val > later.D.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n      val = val > DMax ? 1 : val || DMax;\n      return later.date.next(later.Y.val(month), later.M.val(month), val);\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n      return later.date.prev(later.Y.val(month), later.M.val(month), val > DMax ? DMax : val || DMax);\n    }\n  };\n  later.dayOfWeekCount = later.dc = {\n    name: \"day of week count\",\n    range: 604800,\n    val: function(d) {\n      return d.dc || (d.dc = Math.floor((later.D.val(d) - 1) / 7) + 1);\n    },\n    isValid: function(d, val) {\n      return later.dc.val(d) === val || val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7;\n    },\n    extent: function(d) {\n      return d.dcExtent || (d.dcExtent = [ 1, Math.ceil(later.D.extent(d)[1] / 7) ]);\n    },\n    start: function(d) {\n      return d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, (later.dc.val(d) - 1) * 7 + 1 || 1)));\n    },\n    end: function(d) {\n      return d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));\n    },\n    next: function(d, val) {\n      val = val > later.dc.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n      val = val > dcMax ? 1 : val;\n      var next = later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n      if (next.getTime() <= d.getTime()) {\n        month = later.M.next(d, later.M.val(d) + 1);\n        return later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n      val = val > dcMax ? dcMax : val || dcMax;\n      return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), 1 + 7 * (val - 1)));\n    }\n  };\n  later.dayOfWeek = later.dw = later.d = {\n    name: \"day of week\",\n    range: 86400,\n    val: function(d) {\n      return d.dw || (d.dw = later.date.getDay.call(d) + 1);\n    },\n    isValid: function(d, val) {\n      return later.dw.val(d) === (val || 7);\n    },\n    extent: function() {\n      return [ 1, 7 ];\n    },\n    start: function(d) {\n      return later.D.start(d);\n    },\n    end: function(d) {\n      return later.D.end(d);\n    },\n    next: function(d, val) {\n      val = val > 7 ? 1 : val || 7;\n      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));\n    },\n    prev: function(d, val) {\n      val = val > 7 ? 7 : val || 7;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));\n    }\n  };\n  later.dayOfYear = later.dy = {\n    name: \"day of year\",\n    range: 86400,\n    val: function(d) {\n      return d.dy || (d.dy = Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));\n    },\n    isValid: function(d, val) {\n      return later.dy.val(d) === (val || later.dy.extent(d)[1]);\n    },\n    extent: function(d) {\n      var year = later.Y.val(d);\n      return d.dyExtent || (d.dyExtent = [ 1, year % 4 ? 365 : 366 ]);\n    },\n    start: function(d) {\n      return later.D.start(d);\n    },\n    end: function(d) {\n      return later.D.end(d);\n    },\n    next: function(d, val) {\n      val = val > later.dy.extent(d)[1] ? 1 : val;\n      var year = later.date.nextRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n      val = val > dyMax ? 1 : val || dyMax;\n      return later.date.next(later.Y.val(year), later.M.val(year), val);\n    },\n    prev: function(d, val) {\n      var year = later.date.prevRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n      val = val > dyMax ? dyMax : val || dyMax;\n      return later.date.prev(later.Y.val(year), later.M.val(year), val);\n    }\n  };\n  later.hour = later.h = {\n    name: \"hour\",\n    range: 3600,\n    val: function(d) {\n      return d.h || (d.h = later.date.getHour.call(d));\n    },\n    isValid: function(d, val) {\n      return later.h.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 23 ];\n    },\n    start: function(d) {\n      return d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n    },\n    end: function(d) {\n      return d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n    },\n    next: function(d, val) {\n      val = val > 23 ? 0 : val;\n      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.h.val(d) ? 1 : 0), val);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), val + 1);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 23 ? 23 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.h.val(d) ? -1 : 0), val);\n    }\n  };\n  later.minute = later.m = {\n    name: \"minute\",\n    range: 60,\n    val: function(d) {\n      return d.m || (d.m = later.date.getMin.call(d));\n    },\n    isValid: function(d, val) {\n      return later.m.val(d) === val;\n    },\n    extent: function(d) {\n      return [ 0, 59 ];\n    },\n    start: function(d) {\n      return d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n    },\n    end: function(d) {\n      return d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n    },\n    next: function(d, val) {\n      var m = later.m.val(d), s = later.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later.MIN - s * later.SEC);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = new Date(d.getTime() + (inc + 120) * later.MIN - s * later.SEC);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 59 ? 59 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d) + (val >= later.m.val(d) ? -1 : 0), val);\n    }\n  };\n  later.month = later.M = {\n    name: \"month\",\n    range: 2629740,\n    val: function(d) {\n      return d.M || (d.M = later.date.getMonth.call(d) + 1);\n    },\n    isValid: function(d, val) {\n      return later.M.val(d) === (val || 12);\n    },\n    extent: function() {\n      return [ 1, 12 ];\n    },\n    start: function(d) {\n      return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));\n    },\n    end: function(d) {\n      return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));\n    },\n    next: function(d, val) {\n      val = val > 12 ? 1 : val || 12;\n      return later.date.next(later.Y.val(d) + (val > later.M.val(d) ? 0 : 1), val);\n    },\n    prev: function(d, val) {\n      val = val > 12 ? 12 : val || 12;\n      return later.date.prev(later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0), val);\n    }\n  };\n  later.second = later.s = {\n    name: \"second\",\n    range: 1,\n    val: function(d) {\n      return d.s || (d.s = later.date.getSec.call(d));\n    },\n    isValid: function(d, val) {\n      return later.s.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 59 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      var s = later.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later.SEC);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = new Date(d.getTime() + (inc + 7200) * later.SEC);\n      }\n      return next;\n    },\n    prev: function(d, val, cache) {\n      val = val > 59 ? 59 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d) + (val >= later.s.val(d) ? -1 : 0), val);\n    }\n  };\n  later.time = later.t = {\n    name: \"time\",\n    range: 1,\n    val: function(d) {\n      return d.t || (d.t = later.h.val(d) * 3600 + later.m.val(d) * 60 + later.s.val(d));\n    },\n    isValid: function(d, val) {\n      return later.t.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 86399 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      val = val > 86399 ? 0 : val;\n      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.t.val(d) ? 1 : 0), 0, 0, val);\n      if (!later.date.isUTC && next.getTime() < d.getTime()) {\n        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), val + 7200);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 86399 ? 86399 : val;\n      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.t.val(d) ? -1 : 0), 0, 0, val);\n    }\n  };\n  later.weekOfMonth = later.wm = {\n    name: \"week of month\",\n    range: 604800,\n    val: function(d) {\n      return d.wm || (d.wm = (later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);\n    },\n    isValid: function(d, val) {\n      return later.wm.val(d) === (val || later.wm.extent(d)[1]);\n    },\n    extent: function(d) {\n      return d.wmExtent || (d.wmExtent = [ 1, (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7 ]);\n    },\n    start: function(d) {\n      return d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));\n    },\n    end: function(d) {\n      return d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));\n    },\n    next: function(d, val) {\n      val = val > later.wm.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n      val = val > wmMax ? 1 : val || wmMax;\n      return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2)));\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n      val = val > wmMax ? wmMax : val || wmMax;\n      return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2))));\n    }\n  };\n  later.weekOfYear = later.wy = {\n    name: \"week of year (ISO)\",\n    range: 604800,\n    val: function(d) {\n      if (d.wy) return d.wy;\n      var wThur = later.dw.next(later.wy.start(d), 5), YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur) - 1), 5);\n      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK);\n    },\n    isValid: function(d, val) {\n      return later.wy.val(d) === (val || later.wy.extent(d)[1]);\n    },\n    extent: function(d) {\n      if (d.wyExtent) return d.wyExtent;\n      var year = later.dw.next(later.wy.start(d), 5), dwFirst = later.dw.val(later.Y.start(year)), dwLast = later.dw.val(later.Y.end(year));\n      return d.wyExtent = [ 1, dwFirst === 5 || dwLast === 5 ? 53 : 52 ];\n    },\n    start: function(d) {\n      return d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)));\n    },\n    end: function(d) {\n      return d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)));\n    },\n    next: function(d, val) {\n      val = val > later.wy.extent(d)[1] ? 1 : val;\n      var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.nextRollover(wyThur, val, later.wy, later.Y);\n      if (later.wy.val(year) !== 1) {\n        year = later.dw.next(year, 2);\n      }\n      var wyMax = later.wy.extent(year)[1], wyStart = later.wy.start(year);\n      val = val > wyMax ? 1 : val || wyMax;\n      return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), later.D.val(wyStart) + 7 * (val - 1));\n    },\n    prev: function(d, val) {\n      var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.prevRollover(wyThur, val, later.wy, later.Y);\n      if (later.wy.val(year) !== 1) {\n        year = later.dw.next(year, 2);\n      }\n      var wyMax = later.wy.extent(year)[1], wyEnd = later.wy.end(year);\n      val = val > wyMax ? wyMax : val || wyMax;\n      return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), later.D.val(wyEnd) + 7 * (val - 1)));\n    }\n  };\n  later.year = later.Y = {\n    name: \"year\",\n    range: 31556900,\n    val: function(d) {\n      return d.Y || (d.Y = later.date.getYear.call(d));\n    },\n    isValid: function(d, val) {\n      return later.Y.val(d) === val;\n    },\n    extent: function() {\n      return [ 1970, 2099 ];\n    },\n    start: function(d) {\n      return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));\n    },\n    end: function(d) {\n      return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));\n    },\n    next: function(d, val) {\n      return val > later.Y.val(d) && val <= later.Y.extent()[1] ? later.date.next(val) : later.NEVER;\n    },\n    prev: function(d, val) {\n      return val < later.Y.val(d) && val >= later.Y.extent()[0] ? later.date.prev(val) : later.NEVER;\n    }\n  };\n  later.fullDate = later.fd = {\n    name: \"full date\",\n    range: 1,\n    val: function(d) {\n      return d.fd || (d.fd = d.getTime());\n    },\n    isValid: function(d, val) {\n      return later.fd.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 3250368e7 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      return later.fd.val(d) < val ? new Date(val) : later.NEVER;\n    },\n    prev: function(d, val) {\n      return later.fd.val(d) > val ? new Date(val) : later.NEVER;\n    }\n  };\n  later.modifier = {};\n  later.modifier.after = later.modifier.a = function(constraint, values) {\n    var value = values[0];\n    return {\n      name: \"after \" + constraint.name,\n      range: (constraint.extent(new Date())[1] - value) * constraint.range,\n      val: constraint.val,\n      isValid: function(d, val) {\n        return this.val(d) >= value;\n      },\n      extent: constraint.extent,\n      start: constraint.start,\n      end: constraint.end,\n      next: function(startDate, val) {\n        if (val != value) val = constraint.extent(startDate)[0];\n        return constraint.next(startDate, val);\n      },\n      prev: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[1] : value - 1;\n        return constraint.prev(startDate, val);\n      }\n    };\n  };\n  later.modifier.before = later.modifier.b = function(constraint, values) {\n    var value = values[values.length - 1];\n    return {\n      name: \"before \" + constraint.name,\n      range: constraint.range * (value - 1),\n      val: constraint.val,\n      isValid: function(d, val) {\n        return this.val(d) < value;\n      },\n      extent: constraint.extent,\n      start: constraint.start,\n      end: constraint.end,\n      next: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[0] : value;\n        return constraint.next(startDate, val);\n      },\n      prev: function(startDate, val) {\n        val = val === value ? value - 1 : constraint.extent(startDate)[1];\n        return constraint.prev(startDate, val);\n      }\n    };\n  };\n  later.compile = function(schedDef) {\n    var constraints = [], constraintsLen = 0, tickConstraint;\n    for (var key in schedDef) {\n      var nameParts = key.split(\"_\"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later.modifier[mod](later[name], vals) : later[name];\n      constraints.push({\n        constraint: constraint,\n        vals: vals\n      });\n      constraintsLen++;\n    }\n    constraints.sort(function(a, b) {\n      var ra = a.constraint.range, rb = b.constraint.range;\n      return rb < ra ? -1 : rb > ra ? 1 : 0;\n    });\n    tickConstraint = constraints[constraintsLen - 1].constraint;\n    function compareFn(dir) {\n      return dir === \"next\" ? function(a, b) {\n        return a.getTime() > b.getTime();\n      } : function(a, b) {\n        return b.getTime() > a.getTime();\n      };\n    }\n    return {\n      start: function(dir, startDate) {\n        var next = startDate, nextVal = later.array[dir], maxAttempts = 1e3, done;\n        while (maxAttempts-- && !done && next) {\n          done = true;\n          for (var i = 0; i < constraintsLen; i++) {\n            var constraint = constraints[i].constraint, curVal = constraint.val(next), extent = constraint.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);\n            if (!constraint.isValid(next, newVal)) {\n              next = constraint[dir](next, newVal);\n              done = false;\n              break;\n            }\n          }\n        }\n        if (next !== later.NEVER) {\n          next = dir === \"next\" ? tickConstraint.start(next) : tickConstraint.end(next);\n        }\n        return next;\n      },\n      end: function(dir, startDate) {\n        var result, nextVal = later.array[dir + \"Invalid\"], compare = compareFn(dir);\n        for (var i = constraintsLen - 1; i >= 0; i--) {\n          var constraint = constraints[i].constraint, curVal = constraint.val(startDate), extent = constraint.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;\n          if (newVal !== undefined) {\n            next = constraint[dir](startDate, newVal);\n            if (next && (!result || compare(result, next))) {\n              result = next;\n            }\n          }\n        }\n        return result;\n      },\n      tick: function(dir, date) {\n        return new Date(dir === \"next\" ? tickConstraint.end(date).getTime() + later.SEC : tickConstraint.start(date).getTime() - later.SEC);\n      },\n      tickStart: function(date) {\n        return tickConstraint.start(date);\n      }\n    };\n  };\n  later.schedule = function(sched) {\n    if (!sched) throw new Error(\"Missing schedule definition.\");\n    if (!sched.schedules) throw new Error(\"Definition must include at least one schedule.\");\n    var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;\n    for (var i = 0; i < schedulesLen; i++) {\n      schedules.push(later.compile(sched.schedules[i]));\n    }\n    for (var j = 0; j < exceptionsLen; j++) {\n      exceptions.push(later.compile(sched.exceptions[j]));\n    }\n    function getInstances(dir, count, startDate, endDate, isRange) {\n      var compare = compareFn(dir), loopCount = count, maxAttempts = 1e3, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === \"next\", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;\n      startDate = startDate ? new Date(startDate) : new Date();\n      if (!startDate || !startDate.getTime()) throw new Error(\"Invalid start date.\");\n      setNextStarts(dir, schedules, schedStarts, startDate);\n      setRangeStarts(dir, exceptions, exceptStarts, startDate);\n      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {\n        if (endDate && compare(next, endDate)) {\n          break;\n        }\n        if (exceptionsLen) {\n          updateRangeStarts(dir, exceptions, exceptStarts, next);\n          if (end = calcRangeOverlap(dir, exceptStarts, next)) {\n            updateNextStarts(dir, schedules, schedStarts, end);\n            continue;\n          }\n        }\n        if (isRange) {\n          var maxEndDate = calcMaxEndDate(exceptStarts, compare);\n          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);\n          var r = isForward ? [ new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined ] : [ end ? new Date(endDate ? Math.max(endDate, end.getTime() + later.SEC) : end.getTime() + later.SEC) : undefined, new Date(Math.min(startDate, next.getTime() + later.SEC)) ];\n          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {\n            lastResult[rEnd] = r[rEnd];\n            loopCount++;\n          } else {\n            lastResult = r;\n            results.push(lastResult);\n          }\n          if (!end) break;\n          updateNextStarts(dir, schedules, schedStarts, end);\n        } else {\n          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));\n          tickStarts(dir, schedules, schedStarts, next);\n        }\n        loopCount--;\n      }\n      for (var i = 0, len = results.length; i < len; i++) {\n        var result = results[i];\n        results[i] = Object.prototype.toString.call(result) === \"[object Array]\" ? [ cleanDate(result[0]), cleanDate(result[1]) ] : cleanDate(result);\n      }\n      return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;\n    }\n    function cleanDate(d) {\n      if (d instanceof Date && !isNaN(d.valueOf())) {\n        return new Date(d);\n      }\n      return undefined;\n    }\n    function setNextStarts(dir, schedArr, startsArr, startDate) {\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        startsArr[i] = schedArr[i].start(dir, startDate);\n      }\n    }\n    function updateNextStarts(dir, schedArr, startsArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (startsArr[i] && !compare(startsArr[i], startDate)) {\n          startsArr[i] = schedArr[i].start(dir, startDate);\n        }\n      }\n    }\n    function setRangeStarts(dir, schedArr, rangesArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        var nextStart = schedArr[i].start(dir, startDate);\n        if (!nextStart) {\n          rangesArr[i] = later.NEVER;\n        } else {\n          rangesArr[i] = [ nextStart, schedArr[i].end(dir, nextStart) ];\n        }\n      }\n    }\n    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (rangesArr[i] && !compare(rangesArr[i][0], startDate)) {\n          var nextStart = schedArr[i].start(dir, startDate);\n          if (!nextStart) {\n            rangesArr[i] = later.NEVER;\n          } else {\n            rangesArr[i] = [ nextStart, schedArr[i].end(dir, nextStart) ];\n          }\n        }\n      }\n    }\n    function tickStarts(dir, schedArr, startsArr, startDate) {\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n          startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));\n        }\n      }\n    }\n    function getStart(schedArr, startsArr, startDate, minEndDate) {\n      var result;\n      for (var i = 0, len = startsArr.length; i < len; i++) {\n        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n          var start = schedArr[i].tickStart(startDate);\n          if (minEndDate && start < minEndDate) {\n            return minEndDate;\n          }\n          if (!result || start > result) {\n            result = start;\n          }\n        }\n      }\n      return result;\n    }\n    function calcRangeOverlap(dir, rangesArr, startDate) {\n      var compare = compareFn(dir), result;\n      for (var i = 0, len = rangesArr.length; i < len; i++) {\n        var range = rangesArr[i];\n        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {\n          if (!result || compare(range[1], result)) {\n            result = range[1];\n          }\n        }\n      }\n      return result;\n    }\n    function calcMaxEndDate(exceptsArr, compare) {\n      var result;\n      for (var i = 0, len = exceptsArr.length; i < len; i++) {\n        if (exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {\n          result = exceptsArr[i][0];\n        }\n      }\n      return result;\n    }\n    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {\n      var compare = compareFn(dir), result;\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        var start = startsArr[i];\n        if (start && start.getTime() === startDate.getTime()) {\n          var end = schedArr[i].end(dir, start);\n          if (maxEndDate && (!end || compare(end, maxEndDate))) {\n            return maxEndDate;\n          }\n          if (!result || compare(end, result)) {\n            result = end;\n          }\n        }\n      }\n      return result;\n    }\n    function compareFn(dir) {\n      return dir === \"next\" ? function(a, b) {\n        return !b || a.getTime() > b.getTime();\n      } : function(a, b) {\n        return !a || b.getTime() > a.getTime();\n      };\n    }\n    function findNext(arr, compare) {\n      var next = arr[0];\n      for (var i = 1, len = arr.length; i < len; i++) {\n        if (arr[i] && compare(next, arr[i])) {\n          next = arr[i];\n        }\n      }\n      return next;\n    }\n    return {\n      isValid: function(d) {\n        return getInstances(\"next\", 1, d, d) !== later.NEVER;\n      },\n      next: function(count, startDate, endDate) {\n        return getInstances(\"next\", count || 1, startDate, endDate);\n      },\n      prev: function(count, startDate, endDate) {\n        return getInstances(\"prev\", count || 1, startDate, endDate);\n      },\n      nextRange: function(count, startDate, endDate) {\n        return getInstances(\"next\", count || 1, startDate, endDate, true);\n      },\n      prevRange: function(count, startDate, endDate) {\n        return getInstances(\"prev\", count || 1, startDate, endDate, true);\n      }\n    };\n  };\n  later.setTimeout = function(fn, sched) {\n    var s = later.schedule(sched), t;\n    if (fn) {\n      scheduleTimeout();\n    }\n    function scheduleTimeout() {\n      var now = Date.now(), next = s.next(2, now);\n      if (!next[0]) {\n        t = undefined;\n        return;\n      }\n      var diff = next[0].getTime() - now;\n      if (diff < 1e3) {\n        diff = next[1] ? next[1].getTime() - now : 1e3;\n      }\n      if (diff < 2147483647) {\n        t = setTimeout(fn, diff);\n      } else {\n        t = setTimeout(scheduleTimeout, 2147483647);\n      }\n    }\n    return {\n      isDone: function() {\n        return !t;\n      },\n      clear: function() {\n        clearTimeout(t);\n      }\n    };\n  };\n  later.setInterval = function(fn, sched) {\n    if (!fn) {\n      return;\n    }\n    var t = later.setTimeout(scheduleTimeout, sched), done = t.isDone();\n    function scheduleTimeout() {\n      if (!done) {\n        fn();\n        t = later.setTimeout(scheduleTimeout, sched);\n      }\n    }\n    return {\n      isDone: function() {\n        return t.isDone();\n      },\n      clear: function() {\n        done = true;\n        t.clear();\n      }\n    };\n  };\n  later.date = {};\n  later.date.timezone = function(useLocalTime) {\n    later.date.build = useLocalTime ? function(Y, M, D, h, m, s) {\n      return new Date(Y, M, D, h, m, s);\n    } : function(Y, M, D, h, m, s) {\n      return new Date(Date.UTC(Y, M, D, h, m, s));\n    };\n    var get = useLocalTime ? \"get\" : \"getUTC\", d = Date.prototype;\n    later.date.getYear = d[get + \"FullYear\"];\n    later.date.getMonth = d[get + \"Month\"];\n    later.date.getDate = d[get + \"Date\"];\n    later.date.getDay = d[get + \"Day\"];\n    later.date.getHour = d[get + \"Hours\"];\n    later.date.getMin = d[get + \"Minutes\"];\n    later.date.getSec = d[get + \"Seconds\"];\n    later.date.isUTC = !useLocalTime;\n  };\n  later.date.UTC = function() {\n    later.date.timezone(false);\n  };\n  later.date.localTime = function() {\n    later.date.timezone(true);\n  };\n  later.date.UTC();\n  later.SEC = 1e3;\n  later.MIN = later.SEC * 60;\n  later.HOUR = later.MIN * 60;\n  later.DAY = later.HOUR * 24;\n  later.WEEK = later.DAY * 7;\n  later.DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n  later.NEVER = 0;\n  later.date.next = function(Y, M, D, h, m, s) {\n    return later.date.build(Y, M !== undefined ? M - 1 : 0, D !== undefined ? D : 1, h || 0, m || 0, s || 0);\n  };\n  later.date.nextRollover = function(d, val, constraint, period) {\n    var cur = constraint.val(d), max = constraint.extent(d)[1];\n    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later.SEC) : period.start(d);\n  };\n  later.date.prev = function(Y, M, D, h, m, s) {\n    var len = arguments.length;\n    M = len < 2 ? 11 : M - 1;\n    D = len < 3 ? later.D.extent(later.date.next(Y, M + 1))[1] : D;\n    h = len < 4 ? 23 : h;\n    m = len < 5 ? 59 : m;\n    s = len < 6 ? 59 : s;\n    return later.date.build(Y, M, D, h, m, s);\n  };\n  later.date.prevRollover = function(d, val, constraint, period) {\n    var cur = constraint.val(d);\n    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);\n  };\n  return later;\n}();","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/bower.js":"var later = require(\"../index\");\n\nconsole.log(JSON.stringify({\n  \"name\": \"later\",\n  \"version\": later.version,\n  \"description\": \"Determine later (or previous) occurrences of recurring schedules\",\n  \"keywords\": [\"schedule\", \"occurrences\", \"recur\", \"cron\"],\n  \"author\": \"BunKat <bill@levelstory.com>\",\n  \"repository\" : {\n    \"type\" : \"git\",\n    \"url\" : \"git://github.com/bunkat/later.git\"\n  },\n  \"main\": \"later.js\",\n  \"license\": \"MIT\"\n}, null, 2));","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/component.js":"var later = require(\"../index\");\n\nconsole.log(JSON.stringify({\n  \"name\": \"later\",\n  \"version\": later.version,\n  \"main\": \"./later.js\"\n}, null, 2));","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/end.js":"    return later;\n})();","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/package.js":"var later = require(\"../index\");\n\nconsole.log(JSON.stringify({\n  \"name\": \"later\",\n  \"version\": later.version,\n  \"description\": \"Determine later (or previous) occurrences of recurring schedules\",\n  \"keywords\": [\"schedule\", \"occurrences\", \"recur\", \"cron\"],\n  \"author\": \"BunKat <bill@levelstory.com>\",\n  \"repository\" : {\n    \"type\" : \"git\",\n    \"url\" : \"git://github.com/bunkat/later.git\"\n  },\n  \"main\": \"index.js\",\n  \"browserify\": \"index-browserify.js\",\n  \"jam\": {\n    \"main\": \"later.js\",\n    \"shim\": {\n      \"exports\": \"later\"\n    }\n  },\n  \"devDependencies\": {\n    \"smash\": \"~0.0.8\",\n    \"mocha\": \"*\",\n    \"should\": \">=0.6.3\",\n    \"jslint\": \"*\",\n    \"uglify-js\": \"*\",\n    \"benchmark\": \"*\"\n  },\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"test\": \"./node_modules/.bin/mocha test/**/*-test.js --reporter dot\"\n  }\n}, null, 2));","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/start.js":"/**\n* Later.js\n* (c) 2015 Bill, Levelstory, Inc.\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://bunkat.github.com/later\n*/\nlater = (function() {\n  'use strict';\n\n  var later = {version: \"1.2.0\"}; // semver","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/benchmark/constraint/next-bench.js":"var Benchmark = require('benchmark'),\n    later = require('../../index'),\n    suite = new Benchmark.Suite('next');\n\nsuite\n.add('year', function() {\n  later.year.next(new Date(2012, 4, 15, 20, 15, 13), 2014);\n})\n.add('month', function() {\n  later.month.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('day', function() {\n  later.day.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('hour', function() {\n  later.hour.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('minute', function() {\n  later.minute.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('second', function() {\n  later.second.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('dayofweek', function() {\n  later.dayOfWeek.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('dayofweekcount', function() {\n  later.dayOfWeekCount.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('dayofyear', function() {\n  later.dayOfYear.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('time', function() {\n  later.time.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('weekofmonth', function() {\n  later.weekOfMonth.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.add('weekofyear', function() {\n  later.weekOfYear.next(new Date(2012, 4, 15, 20, 15, 13), 1);\n})\n.on('cycle', function(event) {\n  console.log(String(event.target));\n})\n.run({async: false});","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/benchmark/constraint/val-bench.js":"var Benchmark = require('benchmark'),\n    later = require('../../index'),\n    suite = new Benchmark.Suite('val');\n\nsuite\n/*.add('year', function() {\n  later.year.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('month', function() {\n  later.month.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('day', function() {\n  later.day.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('hour', function() {\n  later.hour.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('minute', function() {\n  later.minute.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('second', function() {\n  later.second.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('dayofweek', function() {\n  later.dayOfWeek.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('dayofweekcount', function() {\n  later.dayOfWeekCount.val(new Date(2012, 4, 15, 20, 15, 13));\n})*/\n.add('dayofyear', function() {\n  later.dayOfYear.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n/*.add('time', function() {\n  later.time.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('weekofmonth', function() {\n  later.weekOfMonth.val(new Date(2012, 4, 15, 20, 15, 13));\n})\n.add('weekofyear', function() {\n  later.weekOfYear.val(new Date(2012, 4, 15, 20, 15, 13));\n})*/\n.on('cycle', function(event) {\n  console.log(String(event.target));\n})\n.run({async: true});","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/benchmark/core/schedule-bench.js":"var Benchmark = require('benchmark'),\n    later = require('../../index'),\n    suite = new Benchmark.Suite('next');\n\nvar schedSimple = later.parse.cron('* */5 * * * *'),\n    compiledSimple = later.schedule(schedSimple);\n\nvar schedComplex = later.parse.cron('0 5 15W * ?'),\n    compiledComplex = later.schedule(schedComplex);\n\nsuite\n.add('simple next', function() {\n  compiledSimple.next();\n})\n.add('complex next', function() {\n  compiledComplex.next();\n})\n.on('cycle', function(event) {\n  console.log(String(event.target));\n})\n.run({async: false});","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/array/array.js":"later.array = {};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/array/nextinvalid.js":"/**\n* Next Invalid\n* (c) 2013 Bill, BunKat LLC.\n*\n* Returns the next invalid value in a range of values, wrapping as needed. Assumes\n* the array has already been sorted.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.array.nextInvalid = function (val, values, extent) {\n\n  var min = extent[0], max = extent[1], len = values.length,\n      zeroVal = values[len-1] === 0 && min !== 0 ? max : 0,\n      next = val,\n      i = values.indexOf(val),\n      start = next;\n\n  while(next === (values[i] || zeroVal)) {\n\n    next++;\n    if(next > max) {\n      next = min;\n    }\n\n    i++;\n    if(i === len) {\n      i = 0;\n    }\n\n    if(next === start) {\n      return undefined;\n    }\n  }\n\n  return next;\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/array/next.js":"/**\n* Next\n* (c) 2013 Bill, BunKat LLC.\n*\n* Returns the next valid value in a range of values, wrapping as needed. Assumes\n* the array has already been sorted.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.array.next = function (val, values, extent) {\n\n  var cur,\n      zeroIsLargest = extent[0] !== 0,\n      nextIdx = 0;\n\n  for(var i = values.length-1; i > -1; --i) {\n    cur = values[i];\n\n    if(cur === val) {\n      return cur;\n    }\n\n    if(cur > val || (cur === 0 && zeroIsLargest && extent[1] > val)) {\n      nextIdx = i;\n      continue;\n    }\n\n    break;\n  }\n\n  return values[nextIdx];\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/array/previnvalid.js":"/**\n* Previous Invalid\n* (c) 2013 Bill, BunKat LLC.\n*\n* Returns the previous invalid value in a range of values, wrapping as needed. Assumes\n* the array has already been sorted.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.array.prevInvalid = function (val, values, extent) {\n\n  var min = extent[0], max = extent[1], len = values.length,\n      zeroVal = values[len-1] === 0 && min !== 0 ? max : 0,\n      next = val,\n      i = values.indexOf(val),\n      start = next;\n\n  while(next === (values[i] || zeroVal)) {\n    next--;\n\n    if(next < min) {\n      next = max;\n    }\n\n    i--;\n    if(i === -1) {\n      i = len-1;\n    }\n\n    if(next === start) {\n      return undefined;\n    }\n  }\n\n  return next;\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/array/prev.js":"/**\n* Previous\n* (c) 2013 Bill, BunKat LLC.\n*\n* Returns the previous valid value in a range of values, wrapping as needed. Assumes\n* the array has already been sorted.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.array.prev = function (val, values, extent) {\n\n  var cur, len = values.length,\n      zeroIsLargest = extent[0] !== 0,\n      prevIdx = len-1;\n\n  for(var i = 0; i < len; i++) {\n    cur = values[i];\n\n    if(cur === val) {\n      return cur;\n    }\n\n    if(cur < val || (cur === 0 && zeroIsLargest && extent[1] < val)) {\n      prevIdx = i;\n      continue;\n    }\n\n    break;\n  }\n\n  return values[prevIdx];\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/array/sort.js":"/**\n* Sort\n* (c) 2013 Bill, BunKat LLC.\n*\n* Sorts an array in natural ascending order, placing zero at the end\n* if zeroIsLast is true.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.array.sort = function (arr, zeroIsLast) {\n  arr.sort(function(a,b) {\n    return +a - +b;\n  });\n\n  if(zeroIsLast && arr[0] === 0) {\n    arr.push(arr.shift());\n  }\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/compat/indexof.js":"// indexOf compares searchElement to elements of the Array using strict\n// equality (the same method used by the ===, or triple-equals, operator).\n//\n// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf\n//\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n        \"use strict\";\n        if (this == null) {\n            throw new TypeError();\n        }\n        var t = Object(this);\n        var len = t.length >>> 0;\n        if (len === 0) {\n            return -1;\n        }\n        var n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n != n) { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n        for (; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    }\n}","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/compat/trim.js":"// The trim method returns the string stripped of whitespace from both ends.\n// trim does not affect the value of the string itself.\n//\n// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim\n//\nif(!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^\\s+|\\s+$/g,'');\n  };\n}","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/day.js":"/**\n* Day Constraint (D)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a day of month (date) constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.day = later.D = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'day',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 86400,\n\n  /**\n  * The day value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.D || (d.D = later.date.getDate.call(d));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.D.val(d) === (val || later.D.extent(d)[1]);\n  },\n\n  /**\n  * The minimum and maximum valid day values of the month specified.\n  * Zero to specify the last day of the month.\n  *\n  * @param {Date} d: The date indicating the month to find the extent of\n  */\n  extent: function(d) {\n    if(d.DExtent) return d.DExtent;\n\n    var month = later.M.val(d),\n        max = later.DAYS_IN_MONTH[month-1];\n\n    if(month === 2 && later.dy.extent(d)[1] === 366) {\n      max = max+1;\n    }\n\n    return (d.DExtent = [1, max]);\n  },\n\n  /**\n  * The start of the day of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.DStart || (d.DStart = later.date.next(\n      later.Y.val(d), later.M.val(d), later.D.val(d)));\n  },\n\n  /**\n  * The end of the day of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.DEnd || (d.DEnd = later.date.prev(\n      later.Y.val(d), later.M.val(d), later.D.val(d)));\n  },\n\n  /**\n  * Returns the start of the next instance of the day value indicated. Returns\n  * the first day of the next month if val is greater than the number of\n  * days in the following month.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > later.D.extent(d)[1] ? 1 : val;\n    var month = later.date.nextRollover(d, val, later.D, later.M),\n        DMax = later.D.extent(month)[1];\n\n    val = val > DMax ? 1 : val || DMax;\n\n    return later.date.next(\n      later.Y.val(month),\n      later.M.val(month),\n      val\n    );\n  },\n\n  /**\n  * Returns the end of the previous instance of the day value indicated. Returns\n  * the last day in the previous month if val is greater than the number of days\n  * in the previous month.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    var month = later.date.prevRollover(d, val, later.D, later.M),\n        DMax = later.D.extent(month)[1];\n\n    return later.date.prev(\n      later.Y.val(month),\n      later.M.val(month),\n      val > DMax ? DMax : val || DMax\n    );\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/dayofweekcount.js":"/**\n* Day of Week Count Constraint (dc)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a day of week count constraint type. This constraint is used\n* to specify schedules like '2nd Tuesday of every month'.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.dayOfWeekCount = later.dc = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'day of week count',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 604800,\n\n  /**\n  * The day of week count value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.dc || (d.dc = Math.floor((later.D.val(d)-1)/7)+1);\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return (later.dc.val(d) === val) ||\n           (val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7);\n  },\n\n  /**\n  * The minimum and maximum valid day values of the month specified.\n  * Zero to specify the last day of week count of the month.\n  *\n  * @param {Date} d: The date indicating the month to find the extent of\n  */\n  extent: function(d) {\n    return d.dcExtent || (d.dcExtent = [1, Math.ceil(later.D.extent(d)[1] /7)]);\n  },\n\n  /**\n  * The first day of the month with the same day of week count as the date\n  * specified.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.dcStart || (d.dcStart =\n      later.date.next(\n        later.Y.val(d),\n        later.M.val(d),\n        Math.max(1, ((later.dc.val(d) - 1) * 7) + 1 || 1)));\n  },\n\n  /**\n  * The last day of the month with the same day of week count as the date\n  * specified.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.dcEnd || (d.dcEnd =\n      later.date.prev(\n        later.Y.val(d),\n        later.M.val(d),\n        Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));\n  },\n\n  /**\n  * Returns the next earliest date with the day of week count specified.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > later.dc.extent(d)[1] ? 1 : val;\n    var month = later.date.nextRollover(d, val, later.dc, later.M),\n        dcMax = later.dc.extent(month)[1];\n\n    val = val > dcMax ? 1 : val;\n\n    var next = later.date.next(\n      later.Y.val(month),\n      later.M.val(month),\n      val === 0 ? later.D.extent(month)[1] - 6 : 1 + (7 * (val - 1))\n    );\n\n    if(next.getTime() <= d.getTime()) {\n      month = later.M.next(d, later.M.val(d)+1);\n\n      return later.date.next(\n        later.Y.val(month),\n        later.M.val(month),\n        val === 0 ? later.D.extent(month)[1] - 6 : 1 + (7 * (val - 1))\n      );\n    }\n\n    return next;\n  },\n\n  /**\n  * Returns the closest previous date with the day of week count specified.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    var month = later.date.prevRollover(d, val, later.dc, later.M),\n        dcMax = later.dc.extent(month)[1];\n\n    val = val > dcMax ? dcMax : val || dcMax;\n\n    return later.dc.end(later.date.prev(\n      later.Y.val(month),\n      later.M.val(month),\n      1 + (7 * (val - 1))\n    ));\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/dayofweek.js":"/**\n* Day of Week Constraint (dw)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a day of week constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.dayOfWeek = later.dw = later.d = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'day of week',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 86400,\n\n  /**\n  * The day of week value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.dw || (d.dw = later.date.getDay.call(d)+1);\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.dw.val(d) === (val || 7);\n  },\n\n  /**\n  * The minimum and maximum valid day of week values. Unlike the standard\n  * Date object, Later day of week goes from 1 to 7.\n  */\n  extent: function() {\n    return [1, 7];\n  },\n\n  /**\n  * The start of the day of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return later.D.start(d);\n  },\n\n  /**\n  * The end of the day of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return later.D.end(d);\n  },\n\n  /**\n  * Returns the start of the next instance of the day of week value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > 7 ? 1 : val || 7;\n\n    return later.date.next(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));\n  },\n\n  /**\n  * Returns the end of the previous instance of the day of week value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    val = val > 7 ? 7 : val || 7;\n\n    return later.date.prev(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));\n  }\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/dayofyear.js":"/**\n* Day of Year Constraint (dy)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a day of year constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.dayOfYear = later.dy = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'day of year',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 86400,\n\n  /**\n  * The day of year value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.dy || (d.dy =\n      Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.dy.val(d) === (val || later.dy.extent(d)[1]);\n  },\n\n  /**\n  * The minimum and maximum valid day of year values of the month specified.\n  * Zero indicates the last day of the year.\n  *\n  * @param {Date} d: The date indicating the month to find the extent of\n  */\n  extent: function(d) {\n    var year = later.Y.val(d);\n\n    // shortcut on finding leap years since this function gets called a lot\n    // works between 1901 and 2099\n    return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);\n  },\n\n  /**\n  * The start of the day of year of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return later.D.start(d);\n  },\n\n  /**\n  * The end of the day of year of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return later.D.end(d);\n  },\n\n  /**\n  * Returns the start of the next instance of the day of year value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > later.dy.extent(d)[1] ? 1 : val;\n    var year = later.date.nextRollover(d, val, later.dy, later.Y),\n        dyMax = later.dy.extent(year)[1];\n\n    val = val > dyMax ? 1 : val || dyMax;\n\n    return later.date.next(\n      later.Y.val(year),\n      later.M.val(year),\n      val\n    );\n\n  },\n\n  /**\n  * Returns the end of the previous instance of the day of year value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    var year = later.date.prevRollover(d, val, later.dy, later.Y),\n        dyMax = later.dy.extent(year)[1];\n\n    val = val > dyMax ? dyMax : val || dyMax;\n\n    return later.date.prev(\n      later.Y.val(year),\n      later.M.val(year),\n      val\n    );\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/fulldate.js":"/**\n* Full date (fd)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for specifying a full date and time.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.fullDate = later.fd = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'full date',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 1,\n\n  /**\n  * The time value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.fd || (d.fd = d.getTime());\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.fd.val(d) === val;\n  },\n\n  /**\n  * The minimum and maximum valid time values.\n  */\n  extent: function() {\n    return [0, 32503680000000];\n  },\n\n  /**\n  * Returns the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d;\n  },\n\n  /**\n  * Returns the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d;\n  },\n\n  /**\n  * Returns the start of the next instance of the time value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    return later.fd.val(d) < val ? new Date(val) : later.NEVER;\n  },\n\n  /**\n  * Returns the end of the previous instance of the time value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    return later.fd.val(d) > val ? new Date(val) : later.NEVER;\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/hour.js":"/**\n* Hour Constraint (H)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a hour constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.hour = later.h = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'hour',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 3600,\n\n  /**\n  * The hour value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.h || (d.h = later.date.getHour.call(d));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.h.val(d) === val;\n  },\n\n  /**\n  * The minimum and maximum valid hour values.\n  */\n  extent: function() {\n    return [0, 23];\n  },\n\n  /**\n  * The start of the hour of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.hStart || (d.hStart = later.date.next(\n      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n  },\n\n  /**\n  * The end of the hour of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.hEnd || (d.hEnd = later.date.prev(\n      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n  },\n\n  /**\n  * Returns the start of the next instance of the hour value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > 23 ? 0 : val;\n\n    var next = later.date.next(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d) + (val <= later.h.val(d) ? 1 : 0),\n      val);\n\n    // correct for passing over a daylight savings boundry\n    if(!later.date.isUTC && next.getTime() <= d.getTime()) {\n      next = later.date.next(\n        later.Y.val(next),\n        later.M.val(next),\n        later.D.val(next),\n        val + 1);\n    }\n\n    return next;\n  },\n\n  /**\n  * Returns the end of the previous instance of the hour value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    val = val > 23 ? 23 : val;\n\n    return later.date.prev(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d) + (val >= later.h.val(d) ? -1 : 0),\n      val);\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/minute.js":"/**\n* Minute Constraint (m)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a minute constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.minute = later.m = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'minute',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 60,\n\n  /**\n  * The minute value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.m || (d.m = later.date.getMin.call(d));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.m.val(d) === val;\n  },\n\n  /**\n  * The minimum and maximum valid minute values.\n  */\n  extent: function(d) {\n    return [0, 59];\n  },\n\n  /**\n  * The start of the minute of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.mStart || (d.mStart = later.date.next(\n      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n  },\n\n  /**\n  * The end of the minute of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.mEnd || (d.mEnd = later.date.prev(\n      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n  },\n\n  /**\n  * Returns the start of the next instance of the minute value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    var m = later.m.val(d),\n        s = later.s.val(d),\n        inc = val > 59 ? 60-m : (val <= m ? (60-m) + val : val-m),\n        next = new Date(d.getTime() + (inc * later.MIN) - (s * later.SEC));\n\n    // correct for passing over a daylight savings boundry\n    if(!later.date.isUTC && next.getTime() <= d.getTime()) {\n      next = new Date(d.getTime() + ((inc + 120) * later.MIN) - (s * later.SEC));\n    }\n\n    return next;\n  },\n\n  /**\n  * Returns the end of the previous instance of the minute value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    val = val > 59 ? 59 : val;\n\n    return later.date.prev(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d),\n      later.h.val(d) + (val >= later.m.val(d) ? -1 : 0),\n      val);\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/month.js":"/**\n* Month Constraint (M)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a month constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.month = later.M = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'month',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 2629740,\n\n  /**\n  * The month value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.M || (d.M = later.date.getMonth.call(d)+1);\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.M.val(d) === (val || 12);\n  },\n\n  /**\n  * The minimum and maximum valid month values. Unlike the native date object,\n  * month values in later are 1 based.\n  */\n  extent: function() {\n    return [1, 12];\n  },\n\n  /**\n  * The start of the month of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));\n  },\n\n  /**\n  * The end of the month of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));\n  },\n\n  /**\n  * Returns the start of the next instance of the month value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > 12 ? 1 : val || 12;\n\n    return later.date.next(\n      later.Y.val(d) + (val > later.M.val(d) ? 0 : 1),\n      val);\n  },\n\n  /**\n  * Returns the end of the previous instance of the month value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    val = val > 12 ? 12 : val || 12;\n\n    return later.date.prev(\n      later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0),\n      val);\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/second.js":"/**\n* Second Constraint (s)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a second constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.second = later.s = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'second',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 1,\n\n  /**\n  * The second value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.s || (d.s = later.date.getSec.call(d));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.s.val(d) === val;\n  },\n\n  /**\n  * The minimum and maximum valid second values.\n  */\n  extent: function() {\n    return [0, 59];\n  },\n\n  /**\n  * The start of the second of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d;\n  },\n\n  /**\n  * The end of the second of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d;\n  },\n\n  /**\n  * Returns the start of the next instance of the second value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    var s = later.s.val(d),\n        inc = val > 59 ? 60-s : (val <= s ? (60-s) + val : val-s),\n        next = new Date(d.getTime() + (inc * later.SEC));\n\n    // correct for passing over a daylight savings boundry\n    if(!later.date.isUTC && next.getTime() <= d.getTime()) {\n      next = new Date(d.getTime() + ((inc + 7200) * later.SEC));\n    }\n\n    return next;\n  },\n\n  /**\n  * Returns the end of the previous instance of the second value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val, cache) {\n    val = val > 59 ? 59 : val;\n\n    return later.date.prev(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d),\n      later.h.val(d),\n      later.m.val(d) + (val >= later.s.val(d) ? -1 : 0),\n      val);\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/time.js":"/**\n* Time Constraint (dy)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a time of day constraint type. Stored as number of seconds\n* since midnight to simplify calculations.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.time = later.t = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'time',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 1,\n\n  /**\n  * The time value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.t || (d.t =\n      (later.h.val(d) * 3600) + (later.m.val(d) * 60) + (later.s.val(d)));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.t.val(d) === val;\n  },\n\n  /**\n  * The minimum and maximum valid time values.\n  */\n  extent: function() {\n    return [0, 86399];\n  },\n\n  /**\n  * Returns the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d;\n  },\n\n  /**\n  * Returns the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d;\n  },\n\n  /**\n  * Returns the start of the next instance of the time value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > 86399 ? 0 : val;\n\n    var next = later.date.next(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d) + (val <= later.t.val(d) ? 1 : 0),\n      0,\n      0,\n      val);\n\n    // correct for passing over a daylight savings boundry\n    if(!later.date.isUTC && next.getTime() < d.getTime()) {\n      next = later.date.next(\n        later.Y.val(next),\n        later.M.val(next),\n        later.D.val(next),\n        later.h.val(next),\n        later.m.val(next),\n        val + 7200);\n    }\n\n    return next;\n  },\n\n  /**\n  * Returns the end of the previous instance of the time value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    val = val > 86399 ? 86399 : val;\n\n    return later.date.next(\n      later.Y.val(d),\n      later.M.val(d),\n      later.D.val(d) + (val >= later.t.val(d) ? -1 : 0),\n      0,\n      0,\n      val);\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/weekofmonth.js":"/**\n* Week of Month Constraint (wy)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for an week of month constraint type. Week of month treats the\n* first of the month as the start of week 1, with each following week starting\n* on Sunday.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.weekOfMonth = later.wm = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'week of month',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 604800,\n\n  /**\n  * The week of month value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.wm || (d.wm =\n      (later.D.val(d) +\n      (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.wm.val(d) === (val || later.wm.extent(d)[1]);\n  },\n\n  /**\n  * The minimum and maximum valid week of month values for the month indicated.\n  * Zero indicates the last week in the month.\n  *\n  * @param {Date} d: The date indicating the month to find values for\n  */\n  extent: function(d) {\n    return d.wmExtent || (d.wmExtent = [1,\n      (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) +\n      (7 - later.dw.val(later.M.end(d)))) / 7]);\n  },\n\n  /**\n  * The start of the week of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.wmStart || (d.wmStart = later.date.next(\n      later.Y.val(d),\n      later.M.val(d),\n      Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));\n  },\n\n  /**\n  * The end of the week of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.wmEnd || (d.wmEnd = later.date.prev(\n      later.Y.val(d),\n      later.M.val(d),\n      Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));\n  },\n\n  /**\n  * Returns the start of the next instance of the week value indicated. Returns\n  * the first day of the next month if val is greater than the number of\n  * days in the following month.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > later.wm.extent(d)[1] ? 1 : val;\n\n    var month = later.date.nextRollover(d, val, later.wm, later.M),\n        wmMax = later.wm.extent(month)[1];\n\n    val = val > wmMax ? 1 : val || wmMax;\n\n    // jump to the Sunday of the desired week, set to 1st of month for week 1\n    return later.date.next(\n        later.Y.val(month),\n        later.M.val(month),\n        Math.max(1, (val-1) * 7 - (later.dw.val(month)-2)));\n  },\n\n  /**\n  * Returns the end of the previous instance of the week value indicated. Returns\n  * the last day of the previous month if val is greater than the number of\n  * days in the previous month.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    var month = later.date.prevRollover(d, val, later.wm, later.M),\n        wmMax = later.wm.extent(month)[1];\n\n    val = val > wmMax ? wmMax : val || wmMax;\n\n    // jump to the end of Saturday of the desired week\n    return later.wm.end(later.date.next(\n        later.Y.val(month),\n        later.M.val(month),\n        Math.max(1, (val-1) * 7 - (later.dw.val(month)-2))));\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/weekofyear.js":"/**\n* Week of Year Constraint (wy)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for an ISO 8601 week constraint type. For more information about\n* ISO 8601 see http://en.wikipedia.org/wiki/ISO_week_date.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.weekOfYear = later.wy = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'week of year (ISO)',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 604800,\n\n  /**\n  * The ISO week year value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    if (d.wy) return d.wy;\n\n    // move to the Thursday in the target week and find Thurs of target year\n    var wThur = later.dw.next(later.wy.start(d), 5),\n        YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur)-1), 5);\n\n    // caculate the difference between the two dates in weeks\n    return (d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.wy.val(d) === (val || later.wy.extent(d)[1]);\n  },\n\n  /**\n  * The minimum and maximum valid ISO week values for the year indicated.\n  *\n  * @param {Date} d: The date indicating the year to find ISO values for\n  */\n  extent: function(d) {\n    if (d.wyExtent) return d.wyExtent;\n\n    // go to start of ISO week to get to the right year\n    var year = later.dw.next(later.wy.start(d), 5),\n        dwFirst = later.dw.val(later.Y.start(year)),\n        dwLast = later.dw.val(later.Y.end(year));\n\n    return (d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52]);\n  },\n\n  /**\n  * The start of the ISO week of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.wyStart || (d.wyStart = later.date.next(\n      later.Y.val(d),\n      later.M.val(d),\n      // jump to the Monday of the current week\n      later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)\n    ));\n  },\n\n  /**\n  * The end of the ISO week of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.wyEnd || (d.wyEnd = later.date.prev(\n      later.Y.val(d),\n      later.M.val(d),\n      // jump to the Saturday of the current week\n      later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)\n    ));\n  },\n\n  /**\n  * Returns the start of the next instance of the ISO week value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    val = val > later.wy.extent(d)[1] ? 1 : val;\n\n    var wyThur = later.dw.next(later.wy.start(d), 5),\n        year = later.date.nextRollover(wyThur, val, later.wy, later.Y);\n\n    // handle case where 1st of year is last week of previous month\n    if(later.wy.val(year) !== 1) {\n      year = later.dw.next(year, 2);\n    }\n\n    var wyMax = later.wy.extent(year)[1],\n        wyStart = later.wy.start(year);\n\n    val = val > wyMax ? 1 : val || wyMax;\n\n    return later.date.next(\n        later.Y.val(wyStart),\n        later.M.val(wyStart),\n        later.D.val(wyStart) + 7 * (val-1)\n      );\n  },\n\n  /**\n  * Returns the end of the previous instance of the ISO week value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    var wyThur = later.dw.next(later.wy.start(d), 5),\n        year = later.date.prevRollover(wyThur, val, later.wy, later.Y);\n\n    // handle case where 1st of year is last week of previous month\n    if(later.wy.val(year) !== 1) {\n      year = later.dw.next(year, 2);\n    }\n\n    var wyMax = later.wy.extent(year)[1],\n        wyEnd = later.wy.end(year);\n\n    val = val > wyMax ? wyMax : val || wyMax;\n\n    return later.wy.end(later.date.next(\n        later.Y.val(wyEnd),\n        later.M.val(wyEnd),\n        later.D.val(wyEnd) + 7 * (val-1)\n      ));\n  }\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/constraint/year.js":"/**\n* Year Constraint (Y)\n* (c) 2013 Bill, BunKat LLC.\n*\n* Definition for a year constraint type.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.year = later.Y = {\n\n  /**\n  * The name of this constraint.\n  */\n  name: 'year',\n\n  /**\n  * The rough amount of seconds between start and end for this constraint.\n  * (doesn't need to be exact)\n  */\n  range: 31556900,\n\n  /**\n  * The year value of the specified date.\n  *\n  * @param {Date} d: The date to calculate the value of\n  */\n  val: function(d) {\n    return d.Y || (d.Y = later.date.getYear.call(d));\n  },\n\n  /**\n  * Returns true if the val is valid for the date specified.\n  *\n  * @param {Date} d: The date to check the value on\n  * @param {Integer} val: The value to validate\n  */\n  isValid: function(d, val) {\n    return later.Y.val(d) === val;\n  },\n\n  /**\n  * The minimum and maximum valid values for the year constraint.\n  * If max is past 2099, later.D.extent must be fixed to calculate leap years\n  * correctly.\n  */\n  extent: function() {\n    return [1970, 2099];\n  },\n\n  /**\n  * The start of the year of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  start: function(d) {\n    return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));\n  },\n\n  /**\n  * The end of the year of the specified date.\n  *\n  * @param {Date} d: The specified date\n  */\n  end: function(d) {\n    return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));\n  },\n\n  /**\n  * Returns the start of the next instance of the year value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  next: function(d, val) {\n    return val > later.Y.val(d) && val <= later.Y.extent()[1] ?\n      later.date.next(val) : later.NEVER;\n  },\n\n  /**\n  * Returns the end of the previous instance of the year value indicated.\n  *\n  * @param {Date} d: The starting date\n  * @param {int} val: The desired value, must be within extent\n  */\n  prev: function(d, val) {\n    return val < later.Y.val(d) && val >= later.Y.extent()[0] ?\n      later.date.prev(val) : later.NEVER;\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/core/compile.js":"/**\n* Compile\n* (c) 2013 Bill, BunKat LLC.\n*\n* Compiles a single schedule definition into a form from which instances can be\n* efficiently calculated from.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.compile = function(schedDef) {\n\n  var constraints = [],\n      constraintsLen = 0,\n      tickConstraint;\n\n  for(var key in schedDef) {\n    var nameParts = key.split('_'),\n        name = nameParts[0],\n        mod = nameParts[1],\n        vals = schedDef[key],\n        constraint = mod ? later.modifier[mod](later[name], vals) : later[name];\n\n    constraints.push({constraint: constraint, vals: vals});\n    constraintsLen++;\n  }\n\n  // sort constraints based on their range for best performance (we want to\n  // always skip the largest block of time possible to find the next valid\n  // value)\n  constraints.sort(function(a,b) {\n    var ra = a.constraint.range, rb = b.constraint.range;\n    return (rb < ra) ? -1 : (rb > ra) ? 1 : 0;\n  });\n\n  // this is the smallest constraint, we use this one to tick the schedule when\n  // finding multiple instances\n  tickConstraint = constraints[constraintsLen-1].constraint;\n\n  /**\n  * Returns a function to use when comparing two dates. Encapsulates the\n  * difference between searching for instances forward and backwards so that\n  * the same code can be completely reused for both directions.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  */\n  function compareFn(dir) {\n    return dir === 'next' ?\n      function(a,b) { return a.getTime() > b.getTime(); } :\n      function(a,b) { return b.getTime() > a.getTime(); };\n  }\n\n  return {\n\n    /**\n    * Calculates the start of the next valid occurrence of a particular schedule\n    * that occurs on or after the specified start time.\n    *\n    * @param {String} dir: Direction to search in ('next' or 'prev')\n    * @param {Date} startDate: The first possible valid occurrence\n    */\n    start: function(dir, startDate) {\n      var next = startDate,\n          nextVal = later.array[dir],\n          maxAttempts = 1000,\n          done;\n\n      while(maxAttempts-- && !done && next) {\n        done = true;\n\n        // verify all of the constraints in order since we want to make the\n        // largest jumps possible to find the first valid value\n        for(var i = 0; i < constraintsLen; i++) {\n\n          var constraint = constraints[i].constraint,\n              curVal = constraint.val(next),\n              extent = constraint.extent(next),\n              newVal = nextVal(curVal, constraints[i].vals, extent);\n\n          if(!constraint.isValid(next, newVal)) {\n            next = constraint[dir](next, newVal);\n            done = false;\n            break; // need to retest all constraints with new date\n          }\n        }\n      }\n\n      if(next !== later.NEVER) {\n        next = dir === 'next' ? tickConstraint.start(next) :\n          tickConstraint.end(next);\n      }\n\n      // if next, move to start of time period. needed when moving backwards\n      return next;\n    },\n\n    /**\n    * Given a valid start time, finds the next schedule that is invalid.\n    * Useful for finding the end of a valid time range.\n    *\n    * @param {Date} startDate: The first possible valid occurrence\n    */\n    end: function(dir, startDate) {\n\n      var result,\n          nextVal = later.array[dir + 'Invalid'],\n          compare = compareFn(dir);\n\n      for(var i = constraintsLen-1; i >= 0; i--) {\n        var constraint = constraints[i].constraint,\n            curVal = constraint.val(startDate),\n            extent = constraint.extent(startDate),\n            newVal = nextVal(curVal, constraints[i].vals, extent),\n            next;\n\n        if(newVal !== undefined) { // constraint has invalid value, use that\n          next = constraint[dir](startDate, newVal);\n          if(next && (!result || compare(result, next))) {\n            result = next;\n          }\n        }\n      }\n\n      return result;\n    },\n\n    /**\n    * Ticks the date by the minimum constraint in this schedule\n    *\n    * @param {String} dir: Direction to tick in ('next' or 'prev')\n    * @param {Date} date: The start date to tick from\n    */\n    tick: function(dir, date) {\n      return new Date(dir === 'next' ?\n        tickConstraint.end(date).getTime() + later.SEC :\n        tickConstraint.start(date).getTime() - later.SEC);\n    },\n\n    /**\n    * Ticks the date to the start of the minimum constraint\n    *\n    * @param {Date} date: The start date to tick from\n    */\n    tickStart: function(date) {\n      return tickConstraint.start(date);\n    }\n\n  };\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/core/schedule.js":"/**\n* Schedule\n* (c) 2013 Bill, BunKat LLC.\n*\n* Returns an object to calculate future or previous occurrences of the\n* specified schedule.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\nlater.schedule = function(sched) {\n  if(!sched) throw new Error('Missing schedule definition.');\n  if(!sched.schedules) throw new Error('Definition must include at least one schedule.');\n\n  // compile the schedule components\n  var schedules = [],\n      schedulesLen = sched.schedules.length,\n      exceptions = [],\n      exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;\n\n  for(var i = 0; i < schedulesLen; i++) {\n    schedules.push(later.compile(sched.schedules[i]));\n  }\n\n  for(var j = 0; j < exceptionsLen; j++) {\n    exceptions.push(later.compile(sched.exceptions[j]));\n  }\n\n  /**\n  * Calculates count number of instances or ranges for the current schedule,\n  * optionally between the specified startDate and endDate.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Integer} count: The number of instances or ranges to return\n  * @param {Date} startDate: The earliest date a valid instance can occur on\n  * @param {Date} endDate: The latest date a valid instance can occur on\n  * @param {Bool} isRange: True to return ranges, false to return instances\n  */\n  function getInstances(dir, count, startDate, endDate, isRange) {\n    var compare = compareFn(dir), // encapsulates difference between directions\n        loopCount = count,\n        maxAttempts = 1000,\n        schedStarts = [], exceptStarts = [],\n        next, end, results = [],\n        isForward = dir === 'next',\n        lastResult,\n        rStart = isForward ? 0 : 1,\n        rEnd = isForward ? 1 : 0;\n\n    startDate = startDate ? new Date(startDate) : new Date();\n    if(!startDate || !startDate.getTime()) throw new Error('Invalid start date.');\n\n    // Step 1: calculate the earliest start dates for each schedule and exception\n    setNextStarts(dir, schedules, schedStarts, startDate);\n    setRangeStarts(dir, exceptions, exceptStarts, startDate);\n\n    // Step 2: select the earliest of the start dates calculated\n    while(maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {\n\n      // Step 3: make sure the start date we found is in range\n      if(endDate && compare(next, endDate)) {\n        break;\n      }\n\n      // Step 4: make sure we aren't in the middle of an exception range\n      if(exceptionsLen) {\n        updateRangeStarts(dir, exceptions, exceptStarts, next);\n        if((end = calcRangeOverlap(dir, exceptStarts, next))) {\n          updateNextStarts(dir, schedules, schedStarts, end);\n          continue;\n        }\n      }\n\n      // Step 5: Date is good, if range, find the end of the range and update start dates\n      if(isRange) {\n        var maxEndDate = calcMaxEndDate(exceptStarts, compare);\n        end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);\n        var r = isForward ?\n          [\n            new Date(Math.max(startDate, next)),\n            end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined\n          ] :\n          [\n            end ? (new Date(endDate ? Math.max(endDate, end.getTime()+later.SEC) : end.getTime()+later.SEC)) : undefined,\n            new Date(Math.min(startDate, next.getTime()+later.SEC))\n          ];\n\n        // make sure start of this range doesn't overlap with the end of the\n        // previous range\n        if(lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {\n          lastResult[rEnd] = r[rEnd];\n          loopCount++; // correct the count since this isn't a new range\n        }\n        else {\n          lastResult = r;\n          results.push(lastResult);\n        }\n\n        if(!end) break; // last iteration valid until the end of time\n        updateNextStarts(dir, schedules, schedStarts, end);\n      }\n      // otherwise store the start date and tick the start dates\n      else {\n        results.push( isForward ?\n          new Date(Math.max(startDate, next)) :\n          getStart(schedules, schedStarts, next, endDate)\n        );\n\n        tickStarts(dir, schedules, schedStarts, next);\n      }\n\n      loopCount--;\n    }\n\n    // clean the dates that will be returned to remove any cached properties\n    // that were added during the schedule process\n    for (var i = 0, len = results.length; i < len; i++) {\n      var result = results[i];\n      results[i] = Object.prototype.toString.call(result) === '[object Array]' ?\n        [ cleanDate(result[0]), cleanDate(result[1]) ] :\n        cleanDate(result);\n    }\n\n    return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;\n  }\n\n  function cleanDate(d) {\n    if(d instanceof Date && !isNaN(d.valueOf())) {\n      return new Date(d);\n    }\n\n    return undefined;\n  }\n\n  /**\n  * Initially sets the first valid next start times\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: Starts earlier than this date will be calculated\n  */\n  function setNextStarts(dir, schedArr, startsArr, startDate) {\n    for(var i = 0, len = schedArr.length; i < len; i++) {\n      startsArr[i] = schedArr[i].start(dir, startDate);\n    }\n  }\n\n  /**\n  * Updates the set of cached start dates to the next valid start dates. Only\n  * schedules where the current start date is less than or equal to the\n  * specified startDate need to be updated.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: Starts earlier than this date will be calculated\n  */\n  function updateNextStarts(dir, schedArr, startsArr, startDate) {\n    var compare = compareFn(dir);\n\n    for(var i = 0, len = schedArr.length; i < len; i++) {\n      if(startsArr[i] && !compare(startsArr[i], startDate)) {\n        startsArr[i] = schedArr[i].start(dir, startDate);\n      }\n    }\n  }\n\n  /**\n  * Updates the set of cached ranges to the next valid ranges. Only\n  * schedules where the current start date is less than or equal to the\n  * specified startDate need to be updated.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: Starts earlier than this date will be calculated\n  */\n  function setRangeStarts(dir, schedArr, rangesArr, startDate) {\n    var compare = compareFn(dir);\n\n    for(var i = 0, len = schedArr.length; i < len; i++) {\n      var nextStart = schedArr[i].start(dir, startDate);\n\n      if(!nextStart) {\n        rangesArr[i] = later.NEVER;\n      }\n      else {\n        rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];\n      }\n    }\n  }\n\n  /**\n  * Updates the set of cached ranges to the next valid ranges. Only\n  * schedules where the current start date is less than or equal to the\n  * specified startDate need to be updated.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: Starts earlier than this date will be calculated\n  */\n  function updateRangeStarts(dir, schedArr, rangesArr, startDate) {\n    var compare = compareFn(dir);\n\n    for(var i = 0, len = schedArr.length; i < len; i++) {\n      if(rangesArr[i] && !compare(rangesArr[i][0], startDate)) {\n        var nextStart = schedArr[i].start(dir, startDate);\n\n        if(!nextStart) {\n          rangesArr[i] = later.NEVER;\n        }\n        else {\n          rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];\n        }\n      }\n    }\n  }\n\n  /**\n  * Increments all schedules with next start equal to startDate by one tick.\n  * Tick size is determined by the smallest constraint within a schedule.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: The date that should cause a schedule to tick\n  */\n  function tickStarts(dir, schedArr, startsArr, startDate) {\n    for(var i = 0, len = schedArr.length; i < len; i++) {\n      if(startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n        startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));\n      }\n    }\n  }\n\n  /**\n  * Determines the start date of the schedule that produced startDate\n  *\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: The date that should cause a schedule to tick\n  * @param {Date} minEndDate: The minimum end date to return\n  */\n  function getStart(schedArr, startsArr, startDate, minEndDate) {\n    var result;\n\n    for(var i = 0, len = startsArr.length; i < len; i++) {\n      if(startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n        var start = schedArr[i].tickStart(startDate);\n\n        if(minEndDate && (start < minEndDate)) {\n          return minEndDate;\n        }\n\n        if(!result || (start > result)) {\n          result = start;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n  * Calculates the end of the overlap between any exception schedule and the\n  * specified start date. Returns undefined if there is no overlap.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} rangesArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: The valid date for which the overlap will be found\n  */\n  function calcRangeOverlap(dir, rangesArr, startDate) {\n    var compare = compareFn(dir), result;\n\n    for(var i = 0, len = rangesArr.length; i < len; i++) {\n      var range = rangesArr[i];\n\n      if(range && !compare(range[0], startDate) &&\n        (!range[1] || compare(range[1], startDate))) {\n        // startDate is in the middle of an exception range\n        if(!result || compare(range[1], result)) {\n          result = range[1];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n  * Calculates the earliest start of an exception schedule, this is the maximum\n  * end date of the schedule.\n  *\n  * @param {Array} exceptsArr: The set of cached exception ranges\n  * @param {Array} compare: The compare function to use to determine earliest\n  */\n  function calcMaxEndDate(exceptsArr, compare) {\n    var result;\n\n    for(var i = 0, len = exceptsArr.length; i < len; i++) {\n      if(exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {\n        result = exceptsArr[i][0];\n      }\n    }\n\n    return result;\n  }\n\n\n  /**\n  * Calculates the next invalid date for a particular schedules starting from\n  * the specified valid start date.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  * @param {Array} schedArr: The set of compiled schedules to use\n  * @param {Array} startsArr: The set of cached start dates for the schedules\n  * @param {Date} startDate: The valid date for which the end date will be found\n  * @param {Date} maxEndDate: The latested possible end date or null for none\n  */\n  function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {\n    var compare = compareFn(dir), result;\n\n    for(var i = 0, len = schedArr.length; i < len; i++) {\n      var start = startsArr[i];\n\n      if(start && start.getTime() === startDate.getTime()) {\n        var end = schedArr[i].end(dir, start);\n\n        // if the end date is past the maxEndDate, just return the maxEndDate\n        if(maxEndDate && (!end || compare(end, maxEndDate))) {\n          return maxEndDate;\n        }\n\n        // otherwise, return the maximum end date that was calculated\n        if(!result || compare(end, result)) {\n          result = end;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n  * Returns a function to use when comparing two dates. Encapsulates the\n  * difference between searching for instances forward and backwards so that\n  * the same code can be completely reused for both directions.\n  *\n  * @param {String} dir: The direction to use, either 'next' or 'prev'\n  */\n  function compareFn(dir) {\n    return dir === 'next' ?\n      function(a,b) { return !b || (a.getTime() > b.getTime()); } :\n      function(a,b) { return !a || (b.getTime() > a.getTime()); };\n  }\n\n  /**\n  * Returns the next value in an array using the function passed in as compare\n  * to do the comparison. Skips over null or undefined values.\n  *\n  * @param {Array} arr: The array of values\n  * @param {Function} compare: The comparison function to use\n  */\n  function findNext(arr, compare) {\n    var next = arr[0];\n\n    for(var i = 1, len = arr.length; i < len; i++) {\n      if(arr[i] && compare(next, arr[i])) {\n        next = arr[i];\n      }\n    }\n\n    return next;\n  }\n\n  return {\n\n    /**\n    * Returns true if d is a valid occurrence of the current schedule.\n    *\n    * @param {Date} d: The date to check\n    */\n    isValid: function(d) {\n      return getInstances('next', 1, d, d) !== later.NEVER;\n    },\n\n    /**\n    * Finds the next valid instance or instances of the current schedule,\n    * optionally between a specified start and end date. Start date is\n    * Date.now() by default, end date is unspecified. Start date must be\n    * smaller than end date.\n    *\n    * @param {Integer} count: The number of instances to return\n    * @param {Date} startDate: The earliest a valid instance can occur\n    * @param {Date} endDate: The latest a valid instance can occur\n    */\n    next: function(count, startDate, endDate) {\n      return getInstances('next', count || 1, startDate, endDate);\n    },\n\n    /**\n    * Finds the previous valid instance or instances of the current schedule,\n    * optionally between a specified start and end date. Start date is\n    * Date.now() by default, end date is unspecified. Start date must be\n    * greater than end date.\n    *\n    * @param {Integer} count: The number of instances to return\n    * @param {Date} startDate: The earliest a valid instance can occur\n    * @param {Date} endDate: The latest a valid instance can occur\n    */\n    prev: function(count, startDate, endDate) {\n      return getInstances('prev', count || 1, startDate, endDate);\n    },\n\n    /**\n    * Finds the next valid range or ranges of the current schedule,\n    * optionally between a specified start and end date. Start date is\n    * Date.now() by default, end date is unspecified. Start date must be\n    * greater than end date.\n    *\n    * @param {Integer} count: The number of ranges to return\n    * @param {Date} startDate: The earliest a valid range can occur\n    * @param {Date} endDate: The latest a valid range can occur\n    */\n    nextRange: function(count, startDate, endDate) {\n      return getInstances('next', count || 1, startDate, endDate, true);\n    },\n\n    /**\n    * Finds the previous valid range or ranges of the current schedule,\n    * optionally between a specified start and end date. Start date is\n    * Date.now() by default, end date is unspecified. Start date must be\n    * greater than end date.\n    *\n    * @param {Integer} count: The number of ranges to return\n    * @param {Date} startDate: The earliest a valid range can occur\n    * @param {Date} endDate: The latest a valid range can occur\n    */\n    prevRange: function(count, startDate, endDate) {\n      return getInstances('prev', count || 1, startDate, endDate, true);\n    }\n  };\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/core/setinterval.js":"/**\n* Set Interval\n* (c) 2013 Bill, BunKat LLC.\n*\n* Works similar to setInterval() but allows you to specify a Later schedule\n* instead of milliseconds.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.setInterval = function(fn, sched) {\n  if (!fn) {\n    return;\n  }\n\n  var t = later.setTimeout(scheduleTimeout, sched),\n      done = t.isDone();\n\n  /**\n  * Executes the specified function and then sets the timeout for the next\n  * interval.\n  */\n  function scheduleTimeout() {\n    if(!done) {\n      fn();\n      t = later.setTimeout(scheduleTimeout, sched);\n    }\n  }\n\n  return {\n\n    isDone: function() {\n      return t.isDone();\n    },\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      done = true;\n      t.clear();\n    }\n\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/core/settimeout.js":"/**\n* Set Timeout\n* (c) 2013 Bill, BunKat LLC.\n*\n* Works similar to setTimeout() but allows you to specify a Later schedule\n* instead of milliseconds.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.setTimeout = function(fn, sched) {\n\n  var s = later.schedule(sched), t;\n  if (fn) {\n    scheduleTimeout();\n  }\n\n  /**\n  * Schedules the timeout to occur. If the next occurrence is greater than the\n  * max supported delay (2147483647 ms) than we delay for that amount before\n  * attempting to schedule the timeout again.\n  */\n  function scheduleTimeout() {\n    var now = Date.now(),\n        next = s.next(2, now);\n\n    if (!next[0]) {\n      t = undefined;\n      return;\n    }\n\n    var diff = next[0].getTime() - now;\n\n    // minimum time to fire is one second, use next occurrence instead\n    if(diff < 1000) {\n      diff = next[1] ? next[1].getTime() - now : 1000;\n    }\n\n    if(diff < 2147483647) {\n      t = setTimeout(fn, diff);\n    }\n    else {\n      t = setTimeout(scheduleTimeout, 2147483647);\n    }\n  }\n\n  return {\n\n    isDone: function() {\n      return !t;\n    },\n\n    /**\n    * Clears the timeout.\n    */\n    clear: function() {\n      clearTimeout(t);\n    }\n\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/date/constant.js":"/**\n* Date Constants\n* (c) 2013 Bill, BunKat LLC.\n*\n* Useful constants for dealing with time conversions.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\n// Time to milliseconds conversion\nlater.SEC = 1000;\nlater.MIN = later.SEC * 60;\nlater.HOUR = later.MIN * 60;\nlater.DAY = later.HOUR * 24;\nlater.WEEK = later.DAY * 7;\n\n// Array of days in each month, must be corrected for leap years\nlater.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n// constant for specifying that a schedule can never occur\nlater.NEVER = 0;","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/date/date.js":"later.date = {};\n\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/date/nextrollover.js":"/**\n* Next Rollover\n* (c) 2013 Bill, BunKat LLC.\n*\n* Determines if a value will cause a particualr constraint to rollover to the\n* next largest time period. Used primarily when a constraint has a\n* variable extent.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.date.nextRollover = function(d, val, constraint, period) {\n  var cur = constraint.val(d),\n      max = constraint.extent(d)[1];\n\n  return (((val || max) <= cur) || val > max) ?\n            new Date(period.end(d).getTime() + later.SEC) :\n            period.start(d);\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/date/prevrollover.js":"/**\n* Prev Rollover\n* (c) 2013 Bill, BunKat LLC.\n*\n* Determines if a value will cause a particualr constraint to rollover to the\n* previous largest time period. Used primarily when a constraint has a\n* variable extent.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.date.prevRollover = function(d, val, constraint, period) {\n  var cur = constraint.val(d);\n\n  return (val >= cur || !val) ?\n            period.start(period.prev(d, period.val(d)-1)) :\n            period.start(d);\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/date/timezone.js":"/**\n* Timezone\n* (c) 2013 Bill, BunKat LLC.\n*\n* Configures helper functions to switch between useing local time and UTC. Later\n* uses UTC time by default.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\nlater.date.timezone = function(useLocalTime) {\n\n  // configure the date builder used to create new dates in the right timezone\n  later.date.build = useLocalTime ?\n    function(Y, M, D, h, m, s) { return new Date(Y, M, D, h, m, s); } :\n    function(Y, M, D, h, m, s) { return new Date(Date.UTC(Y, M, D, h, m, s)); };\n\n  // configure the accessor methods\n  var get = useLocalTime ? 'get' : 'getUTC',\n      d = Date.prototype;\n\n  later.date.getYear = d[get + 'FullYear'];\n  later.date.getMonth = d[get + 'Month'];\n  later.date.getDate = d[get + 'Date'];\n  later.date.getDay = d[get + 'Day'];\n  later.date.getHour = d[get + 'Hours'];\n  later.date.getMin = d[get + 'Minutes'];\n  later.date.getSec = d[get + 'Seconds'];\n\n  // set the isUTC flag\n  later.date.isUTC = !useLocalTime;\n};\n\n// friendly names for available timezones\nlater.date.UTC = function() { later.date.timezone(false); };\nlater.date.localTime = function() { later.date.timezone(true); };\n\n// use UTC by default\nlater.date.UTC();","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/modifier/after.js":"/**\n* After Modifier\n* (c) 2013 Bill, BunKat LLC.\n*\n* Modifies a constraint such that all values that are greater than the\n* specified value are considered valid.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\n/**\n* Creates a new modified constraint.\n*\n* @param {Constraint} constraint: The constraint to be modified\n* @param {Integer} value: The starting value of the after constraint\n*/\nlater.modifier.after = later.modifier.a = function(constraint, values) {\n\n  var value = values[0];\n\n  return {\n\n    /**\n    * Returns the name of the constraint with the 'after' modifier.\n    */\n    name: 'after ' + constraint.name,\n\n    /**\n    * Pass through to the constraint.\n    */\n    range: (constraint.extent(new Date())[1] - value) * constraint.range,\n\n    /**\n    * The value of the specified date. Returns value for any constraint val\n    * that is greater than or equal to value.\n    *\n    * @param {Date} d: The date to calculate the value of\n    */\n    val: constraint.val,\n\n    /**\n    * Returns true if the val is valid for the date specified.\n    *\n    * @param {Date} d: The date to check the value on\n    * @param {Integer} val: The value to validate\n    */\n    isValid: function(d, val) {\n      return this.val(d) >= value;\n    },\n\n    /**\n    * Pass through to the constraint.\n    */\n    extent: constraint.extent,\n\n    /**\n    * Pass through to the constraint.\n    */\n    start: constraint.start,\n\n    /**\n    * Pass through to the constraint.\n    */\n    end: constraint.end,\n\n    /**\n    * Pass through to the constraint.\n    */\n    next: function(startDate, val) {\n        if(val != value) val = constraint.extent(startDate)[0];\n        return constraint.next(startDate, val);\n    },\n\n    /**\n    * Pass through to the constraint.\n    */\n    prev: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[1] : value - 1;\n        return constraint.prev(startDate, val);\n    }\n\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/modifier/before.js":"/**\n* Before Modifier\n* (c) 2013 Bill, BunKat LLC.\n*\n* Modifies a constraint such that all values that are less than the\n* specified value are considered valid.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\n/**\n* Creates a new modified constraint.\n*\n* @param {Constraint} constraint: The constraint to be modified\n* @param {Integer} value: The starting value of the before constraint\n*/\nlater.modifier.before = later.modifier.b = function(constraint, values) {\n\n  var value = values[values.length-1];\n\n  return {\n\n    /**\n    * Returns the name of the constraint with the 'before' modifier.\n    */\n    name: 'before ' + constraint.name,\n\n    /**\n    * Pass through to the constraint.\n    */\n    range: constraint.range * (value-1),\n\n    /**\n    * The value of the specified date. Returns value for any constraint val\n    * that is less than or equal to value.\n    *\n    * @param {Date} d: The date to calculate the value of\n    */\n    val: constraint.val,\n\n    /**\n    * Returns true if the val is valid for the date specified.\n    *\n    * @param {Date} d: The date to check the value on\n    * @param {Integer} val: The value to validate\n    */\n    isValid: function(d, val) {\n      return this.val(d) < value;\n    },\n\n    /**\n    * Pass through to the constraint.\n    */\n    extent: constraint.extent,\n\n    /**\n    * Pass through to the constraint.\n    */\n    start: constraint.start,\n\n    /**\n    * Jump to the end of the range.\n    */\n    end: constraint.end,\n\n    /**\n    * Pass through to the constraint.\n    */\n    next: function(startDate, val) {\n      val = val === value ? constraint.extent(startDate)[0] : value;\n      return constraint.next(startDate, val);\n    },\n\n    /**\n    * Pass through to the constraint.\n    */\n    prev: function(startDate, val) {\n      val = val === value ? value - 1 : constraint.extent(startDate)[1];\n      return constraint.prev(startDate, val);\n    }\n\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/modifier/modifier.js":"\nlater.modifier = {};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/parse/cron.js":"/**\n* Cron\n* (c) 2013 Bill, BunKat LLC.\n*\n* Creates a valid Later schedule from a valid cron expression.\n*\n* Later is freely distributable under the MIT license.\n* For all details and documentation:\n*     http://github.com/bunkat/later\n*/\n\n/**\n* Parses a valid cron expression and produces a valid schedule that\n* can then be used with Later.\n*\n* CronParser().parse('* 5 * * * * *', true);\n*\n* @param {String} expr: The cron expression to parse\n* @param {Bool} hasSeconds: True if the expression uses a seconds field\n* @api public\n*/\nlater.parse.cron = function (expr, hasSeconds) {\n\n  // Constant array to convert valid names to values\n  var NAMES = {\n    JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,\n    SEP: 9, OCT: 10, NOV: 11, DEC: 12,\n    SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7\n  };\n\n  // Parsable replacements for common expressions\n  var REPLACEMENTS = {\n    '* * * * * *': '0/1 * * * * *',\n    '@YEARLY': '0 0 1 1 *',\n    '@ANNUALLY': '0 0 1 1 *',\n    '@MONTHLY': '0 0 1 * *',\n    '@WEEKLY': '0 0 * * 0',\n    '@DAILY': '0 0 * * *',\n    '@HOURLY': '0 * * * *'\n  };\n\n  // Contains the index, min, and max for each of the constraints\n  var FIELDS = {\n    s: [0, 0, 59],      // seconds\n    m: [1, 0, 59],      // minutes\n    h: [2, 0, 23],      // hours\n    D: [3, 1, 31],      // day of month\n    M: [4, 1, 12],      // month\n    Y: [6, 1970, 2099], // year\n    d: [5, 1, 7, 1]     // day of week\n  };\n\n  /**\n  * Returns the value + offset if value is a number, otherwise it\n  * attempts to look up the value in the NAMES table and returns\n  * that result instead.\n  *\n  * @param {Int,String} value: The value that should be parsed\n  * @param {Int} offset: Any offset that must be added to the value\n  */\n  function getValue(value, offset, max) {\n    return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);\n  }\n\n  /**\n  * Returns a deep clone of a schedule skipping any day of week\n  * constraints.\n  *\n  * @param {Sched} sched: The schedule that will be cloned\n  */\n  function cloneSchedule(sched) {\n    var clone = {}, field;\n\n    for(field in sched) {\n      if (field !== 'dc' && field !== 'd') {\n        clone[field] = sched[field].slice(0);\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n  * Adds values to the specified constraint in the current schedule.\n  *\n  * @param {Sched} sched: The schedule to add the constraint to\n  * @param {String} name: Name of constraint to add\n  * @param {Int} min: Minimum value for this constraint\n  * @param {Int} max: Maximum value for this constraint\n  * @param {Int} inc: The increment to use between min and max\n  */\n  function add(sched, name, min, max, inc) {\n    var i = min;\n\n    if (!sched[name]) {\n      sched[name] = [];\n    }\n\n    while (i <= max) {\n      if (sched[name].indexOf(i) < 0) {\n        sched[name].push(i);\n      }\n      i += inc || 1;\n    }\n\n    sched[name].sort(function(a,b) { return a - b; });\n  }\n\n  /**\n  * Adds a hash item (of the form x#y or xL) to the schedule.\n  *\n  * @param {Schedule} schedules: The current schedule array to add to\n  * @param {Schedule} curSched: The current schedule to add to\n  * @param {Int} value: The value to add (x of x#y or xL)\n  * @param {Int} hash: The hash value to add (y of x#y)\n  */\n  function addHash(schedules, curSched, value, hash) {\n    // if there are any existing day of week constraints that\n    // aren't equal to the one we're adding, create a new\n    // composite schedule\n    if ((curSched.d && !curSched.dc) ||\n        (curSched.dc && curSched.dc.indexOf(hash) < 0)) {\n      schedules.push(cloneSchedule(curSched));\n      curSched = schedules[schedules.length-1];\n    }\n\n    add(curSched, 'd', value, value);\n    add(curSched, 'dc', hash, hash);\n  }\n\n  function addWeekday(s, curSched, value) {\n     var except1 = {}, except2 = {};\n     if (value=== 1) {\n      // cron doesn't pass month boundaries, so if 1st is a\n      // weekend then we need to use 2nd or 3rd instead\n      add(curSched, 'D', 1, 3);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', 2, 2);\n      add(except1, 'd', NAMES.TUE, NAMES.FRI);\n      add(except2, 'D', 3, 3);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    } else {\n      // normally you want the closest day, so if v is a\n      // Saturday, use the previous Friday.  If it's a\n      // sunday, use the following Monday.\n      add(curSched, 'D', value-1, value+1);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', value-1, value-1);\n      add(except1, 'd', NAMES.MON, NAMES.THU);\n      add(except2, 'D', value+1, value+1);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    }\n    s.exceptions.push(except1);\n    s.exceptions.push(except2);\n  }\n\n  /**\n  * Adds a range item (of the form x-y/z) to the schedule.\n  *\n  * @param {String} item: The cron expression item to add\n  * @param {Schedule} curSched: The current schedule to add to\n  * @param {String} name: The name to use for this constraint\n  * @param {Int} min: The min value for the constraint\n  * @param {Int} max: The max value for the constraint\n  * @param {Int} offset: The offset to apply to the cron value\n  */\n  function addRange(item, curSched, name, min, max, offset) {\n    // parse range/x\n    var incSplit = item.split('/'),\n        inc = +incSplit[1],\n        range = incSplit[0];\n\n    // parse x-y or * or 0\n    if (range !== '*' && range !== '0') {\n      var rangeSplit = range.split('-');\n      min = getValue(rangeSplit[0], offset, max);\n\n      // fix for issue #13, range may be single digit\n      max = getValue(rangeSplit[1], offset, max) || max;\n    }\n\n    add(curSched, name, min, max, inc);\n  }\n\n  /**\n  * Parses a particular item within a cron expression.\n  *\n  * @param {String} item: The cron expression item to parse\n  * @param {Schedule} s: The existing set of schedules\n  * @param {String} name: The name to use for this constraint\n  * @param {Int} min: The min value for the constraint\n  * @param {Int} max: The max value for the constraint\n  * @param {Int} offset: The offset to apply to the cron value\n  */\n  function parse(item, s, name, min, max, offset) {\n    var value,\n        split,\n        schedules = s.schedules,\n        curSched = schedules[schedules.length-1];\n\n    // L just means min - 1 (this also makes it work for any field)\n    if (item === 'L') {\n      item = min - 1;\n    }\n\n    // parse x\n    if ((value = getValue(item, offset, max)) !== null) {\n      add(curSched, name, value, value);\n    }\n    // parse xW\n    else if ((value = getValue(item.replace('W', ''), offset, max)) !== null) {\n      addWeekday(s, curSched, value);\n    }\n    // parse xL\n    else if ((value = getValue(item.replace('L', ''), offset, max)) !== null) {\n      addHash(schedules, curSched, value, min-1);\n    }\n    // parse x#y\n    else if ((split = item.split('#')).length === 2) {\n      value = getValue(split[0], offset, max);\n      addHash(schedules, curSched, value, getValue(split[1]));\n    }\n    // parse x-y or x-y/z or */z or 0/z\n    else {\n      addRange(item, curSched, name, min, max, offset);\n    }\n  }\n\n  /**\n  * Returns true if the item is either of the form x#y or xL.\n  *\n  * @param {String} item: The expression item to check\n  */\n  function isHash(item) {\n    return item.indexOf('#') > -1 || item.indexOf('L') > 0;\n  }\n\n\n  function itemSorter(a,b) {\n    return isHash(a) && !isHash(b) ? 1 : a - b;\n  }\n\n  /**\n  * Parses each of the fields in a cron expression.  The expression must\n  * include the seconds field, the year field is optional.\n  *\n  * @param {String} expr: The cron expression to parse\n  */\n  function parseExpr(expr) {\n    var schedule = {schedules: [{}], exceptions: []},\n        components = expr.replace(/(\\s)+/g, ' ').split(' '),\n        field, f, component, items;\n\n    for(field in FIELDS) {\n      f = FIELDS[field];\n      component = components[f[0]];\n      if (component && component !== '*' && component !== '?') {\n        // need to sort so that any #'s come last, otherwise\n        // schedule clones to handle # won't contain all of the\n        // other constraints\n        items = component.split(',').sort(itemSorter);\n        var i, length = items.length;\n        for (i = 0; i < length; i++) {\n          parse(items[i], schedule, field, f[1], f[2], f[3]);\n        }\n      }\n    }\n\n    return schedule;\n  }\n\n  /**\n  * Make cron expression parsable.\n  *\n  * @param {String} expr: The cron expression to prepare\n  */\n  function prepareExpr(expr) {\n    var prepared = expr.toUpperCase();\n    return REPLACEMENTS[prepared] || prepared;\n  }\n\n  var e = prepareExpr(expr);\n  return parseExpr(hasSeconds ? e : '0 ' + e);\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/parse/parse.js":"later.parse = {};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/parse/recur.js":"/**\n* Simple API for generating valid schedules for Later.js.  All commands\n* are chainable.\n*\n* Example:\n*\n* Every 5 minutes between minutes 15 and 45 of each hour and also\n* at 9:00 am every day, except in the months of January and February\n*\n* recur().every(5).minute().between(15, 45).and().at('09:00:00')\n*    .except().on(0, 1).month();\n*/\nlater.parse.recur = function () {\n\n  var schedules = [],\n      exceptions = [],\n      cur,\n      curArr = schedules,\n      curName,\n      values, every, modifier, applyMin, applyMax, i, last;\n\n  /**\n  * Adds values to the specified constraint in the current schedule.\n  *\n  * @param {String} name: Name of constraint to add\n  * @param {Int} min: Minimum value for this constraint\n  * @param {Int} max: Maximum value for this constraint\n  */\n  function add(name, min, max) {\n    name = modifier ? name + '_' + modifier : name;\n\n    if (!cur) {\n      curArr.push({});\n      cur = curArr[0];\n    }\n\n    if (!cur[name]) {\n      cur[name] = [];\n    }\n\n    curName = cur[name];\n\n    if (every) {\n      values = [];\n      for (i = min; i <= max; i += every) {\n        values.push(i);\n      }\n\n      // save off values in case of startingOn or between\n      last = {n: name, x: every, c: curName.length, m: max};\n    }\n\n    values = applyMin ? [min] : applyMax ? [max] : values;\n    var length = values.length;\n    for (i = 0; i < length; i += 1) {\n      var val = values[i];\n      if (curName.indexOf(val) < 0) {\n        curName.push(val);\n      }\n    }\n\n    // reset the built up state\n    values = every = modifier = applyMin = applyMax = 0;\n  }\n\n  return {\n\n    /**\n    * Set of constraints that must be met for an occurrence to be valid.\n    *\n    * @api public\n    */\n    schedules: schedules,\n\n    /**\n    * Set of exceptions that must not be met for an occurrence to be\n    * valid.\n    *\n    * @api public\n    */\n    exceptions: exceptions,\n\n    /**\n    * Specifies the specific instances of a time period that are valid.\n    * Must be followed by the desired time period (minute(), hour(),\n    * etc). For example, to specify a schedule for the 5th and 25th\n    * minute of every hour:\n    *\n    * recur().on(5, 25).minute();\n    *\n    * @param {Int} args: One or more valid instances\n    * @api public\n    */\n    on: function () {\n      values = arguments[0] instanceof Array ? arguments[0] : arguments;\n      return this;\n    },\n\n    /**\n    * Specifies the recurring interval of a time period that are valid.\n    * Must be followed by the desired time period (minute(), hour(),\n    * etc). For example, to specify a schedule for every 4 hours in the\n    * day:\n    *\n    * recur().every(4).hour();\n    *\n    * @param {Int} x: Recurring interval\n    * @api public\n    */\n    every: function (x) {\n      every = x || 1;\n      return this;\n    },\n\n    /**\n    * Specifies the minimum valid value.  For example, to specify a schedule\n    * that is valid for all hours after four:\n    *\n    * recur().after(4).hour();\n    *\n    * @param {Int} x: Recurring interval\n    * @api public\n    */\n    after: function (x) {\n      modifier = 'a';\n      values = [x];\n      return this;\n    },\n\n    /**\n    * Specifies the maximum valid value.  For example, to specify a schedule\n    * that is valid for all hours before four:\n    *\n    * recur().before(4).hour();\n    *\n    * @param {Int} x: Recurring interval\n    * @api public\n    */\n    before: function (x) {\n      modifier = 'b';\n      values = [x];\n      return this;\n    },\n\n    /**\n    * Specifies that the first instance of a time period is valid. Must\n    * be followed by the desired time period (minute(), hour(), etc).\n    * For example, to specify a schedule for the first day of every\n    * month:\n    *\n    * recur().first().dayOfMonth();\n    *\n    * @api public\n    */\n    first: function () {\n      applyMin = 1;\n      return this;\n    },\n\n    /**\n    * Specifies that the last instance of a time period is valid. Must\n    * be followed by the desired time period (minute(), hour(), etc).\n    * For example, to specify a schedule for the last day of every year:\n    *\n    * recur().last().dayOfYear();\n    *\n    * @api public\n    */\n    last: function () {\n      applyMax = 1;\n      return this;\n    },\n\n    /**\n    * Specifies a specific time that is valid. Time must be specified in\n    * hh:mm:ss format using 24 hour time. For example, to specify\n    * a schedule for 8:30 pm every day:\n    *\n    * recur().time('20:30:00');\n    *\n    * @param {String} time: Time in hh:mm:ss 24-hour format\n    * @api public\n    */\n    time: function () {\n      //values = arguments;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var split = values[i].split(':');\n        if(split.length < 3) split.push(0);\n        values[i] = (+split[0]) * 3600 + (+split[1]) * 60 + (+split[2]);\n      }\n\n      add('t');\n      return this;\n    },\n\n    /**\n    * Seconds time period, denotes seconds within each minute.\n    * Minimum value is 0, maximum value is 59. Specify 59 for last.\n    *\n    * recur().on(5, 15, 25).second();\n    *\n    * @api public\n    */\n    second: function () {\n      add('s', 0, 59);\n      return this;\n    },\n\n    /**\n    * Minutes time period, denotes minutes within each hour.\n    * Minimum value is 0, maximum value is 59. Specify 59 for last.\n    *\n    * recur().on(5, 15, 25).minute();\n    *\n    * @api public\n    */\n    minute: function () {\n      add('m', 0, 59);\n      return this;\n    },\n\n    /**\n    * Hours time period, denotes hours within each day.\n    * Minimum value is 0, maximum value is 23. Specify 23 for last.\n    *\n    * recur().on(5, 15, 25).hour();\n    *\n    * @api public\n    */\n    hour: function () {\n      add('h', 0, 23);\n      return this;\n    },\n\n    /**\n    * Days of month time period, denotes number of days within a month.\n    * Minimum value is 1, maximum value is 31.  Specify 0 for last.\n    *\n    * recur().every(2).dayOfMonth();\n    *\n    * @api public\n    */\n    dayOfMonth: function () {\n      add('D', 1, applyMax ? 0 : 31);\n      return this;\n    },\n\n    /**\n    * Days of week time period, denotes the days within a week.\n    * Minimum value is 1, maximum value is 7.  Specify 0 for last.\n    * 1 - Sunday\n    * 2 - Monday\n    * 3 - Tuesday\n    * 4 - Wednesday\n    * 5 - Thursday\n    * 6 - Friday\n    * 7 - Saturday\n    *\n    * recur().on(1).dayOfWeek();\n    *\n    * @api public\n    */\n    dayOfWeek: function () {\n      add('d', 1, 7);\n      return this;\n    },\n\n    /**\n    * Short hand for on(1,7).dayOfWeek()\n    *\n    * @api public\n    */\n    onWeekend: function() {\n      values = [1,7];\n      return this.dayOfWeek();\n    },\n\n    /**\n    * Short hand for on(2,3,4,5,6).dayOfWeek()\n    *\n    * @api public\n    */\n    onWeekday: function() {\n      values = [2,3,4,5,6];\n      return this.dayOfWeek();\n    },\n\n    /**\n    * Days of week count time period, denotes the number of times a\n    * particular day has occurred within a month.  Used to specify\n    * things like second Tuesday, or third Friday in a month.\n    * Minimum value is 1, maximum value is 5.  Specify 0 for last.\n    * 1 - First occurrence\n    * 2 - Second occurrence\n    * 3 - Third occurrence\n    * 4 - Fourth occurrence\n    * 5 - Fifth occurrence\n    * 0 - Last occurrence\n    *\n    * recur().on(1).dayOfWeek().on(1).dayOfWeekCount();\n    *\n    * @api public\n    */\n    dayOfWeekCount: function () {\n      add('dc', 1, applyMax ? 0 : 5);\n      return this;\n    },\n\n    /**\n    * Days of year time period, denotes number of days within a year.\n    * Minimum value is 1, maximum value is 366.  Specify 0 for last.\n    *\n    * recur().every(2).dayOfYear();\n    *\n    * @api public\n    */\n    dayOfYear: function () {\n      add('dy', 1, applyMax ? 0 : 366);\n      return this;\n    },\n\n    /**\n    * Weeks of month time period, denotes number of weeks within a\n    * month. The first week is the week that includes the 1st of the\n    * month. Subsequent weeks start on Sunday.\n    * Minimum value is 1, maximum value is 5.  Specify 0 for last.\n    * February 2nd,  2012 - Week 1\n    * February 5th,  2012 - Week 2\n    * February 12th, 2012 - Week 3\n    * February 19th, 2012 - Week 4\n    * February 26th, 2012 - Week 5 (or 0)\n    *\n    * recur().on(2).weekOfMonth();\n    *\n    * @api public\n    */\n    weekOfMonth: function () {\n      add('wm', 1, applyMax ? 0 : 5);\n      return this;\n    },\n\n    /**\n    * Weeks of year time period, denotes the ISO 8601 week date. For\n    * more information see: http://en.wikipedia.org/wiki/ISO_week_date.\n    * Minimum value is 1, maximum value is 53.  Specify 0 for last.\n    *\n    * recur().every(2).weekOfYear();\n    *\n    * @api public\n    */\n    weekOfYear: function () {\n      add('wy', 1, applyMax ? 0 : 53);\n      return this;\n    },\n\n    /**\n    * Month time period, denotes the months within a year.\n    * Minimum value is 1, maximum value is 12.  Specify 0 for last.\n    * 1 - January\n    * 2 - February\n    * 3 - March\n    * 4 - April\n    * 5 - May\n    * 6 - June\n    * 7 - July\n    * 8 - August\n    * 9 - September\n    * 10 - October\n    * 11 - November\n    * 12 - December\n    *\n    * recur().on(1).dayOfWeek();\n    *\n    * @api public\n    */\n    month: function () {\n      add('M', 1, 12);\n      return this;\n    },\n\n    /**\n    * Year time period, denotes the four digit year.\n    * Minimum value is 1970, maximum value is Jan 1, 2100 (arbitrary)\n    *\n    * recur().on(2011, 2012, 2013).year();\n    *\n    * @api public\n    */\n    year: function () {\n      add('Y', 1970, 2450);\n      return this;\n    },\n\n    /**\n    * Full date period, denotes a full date and time.\n    * Minimum value is Jan 1, 1970, maximum value is Jan 1, 2100 (arbitrary)\n    *\n    * recur().on(new Date(2013, 3, 2, 10, 30, 0)).fullDate();\n    *\n    * @api public\n    */\n    fullDate: function () {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i] = values[i].getTime();\n      }\n\n      add('fd');\n      return this;\n    },\n\n    /**\n    * Custom modifier.\n    *\n    * recur().on(2011, 2012, 2013).custom('partOfDay');\n    *\n    * @api public\n    */\n    customModifier: function (id, vals) {\n      var custom = later.modifier[id];\n      if(!custom) throw new Error('Custom modifier ' + id + ' not recognized!');\n\n      modifier = id;\n      values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];\n      return this;\n    },\n\n    /**\n    * Custom time period.\n    *\n    * recur().on(2011, 2012, 2013).customPeriod('partOfDay');\n    *\n    * @api public\n    */\n    customPeriod: function (id) {\n      var custom = later[id];\n      if(!custom) throw new Error('Custom time period ' + id + ' not recognized!');\n\n      add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);\n      return this;\n    },\n\n    /**\n    * Modifies a recurring interval (specified using every) to start\n    * at a given offset.  To create a schedule for every 5 minutes\n    * starting on the 6th minute - making minutes 6, 11, 16, etc valid:\n    *\n    * recur().every(5).minute().startingOn(6);\n    *\n    * @param {Int} start: The desired starting offset\n    * @api public\n    */\n    startingOn: function (start) {\n      return this.between(start, last.m);\n    },\n\n    /**\n    * Modifies a recurring interval (specified using every) to start\n    * and stop at specified times.  To create a schedule for every\n    * 5 minutes starting on the 6th minute and ending on the 11th\n    * minute - making minutes 6 and 11 valid:\n    *\n    * recur().every(5).minute().between(6, 11);\n    *\n    * @param {Int} start: The desired starting offset\n    * @param {Int} end: The last valid value\n    * @api public\n    */\n    between: function (start, end) {\n      // remove the values added as part of specifying the last\n      // time period and replace them with the new restricted values\n      cur[last.n] = cur[last.n].splice(0, last.c);\n      every = last.x;\n      add(last.n, start, end);\n      return this;\n    },\n\n    /**\n    * Creates a composite schedule.  With a composite schedule, a valid\n    * occurrence of any of the component schedules is considered a valid\n    * value for the composite schedule (e.g. they are OR'ed together).\n    * To create a schedule for every 5 minutes on Mondays and every 10\n    * minutes on Tuesdays:\n    *\n    * recur().every(5).minutes().on(1).dayOfWeek().and().every(10)\n    *    .minutes().on(2).dayOfWeek();\n    *\n    * @api public\n    */\n    and: function () {\n      cur = curArr[curArr.push({}) - 1];\n      return this;\n    },\n\n    /**\n    * Creates exceptions to a schedule. Any valid occurrence of the\n    * exception schedule (which may also be composite schedules) is\n    * considered a invalid schedule occurrence. Everything that follows\n    * except will be treated as an exception schedule.  To create a\n    * schedule for 8:00 am every Tuesday except for patch Tuesday\n    * (second Tuesday each month):\n    *\n    * recur().at('08:00:00').on(2).dayOfWeek().except()\n    *    .dayOfWeekCount(1);\n    *\n    * @api public\n    */\n    except: function () {\n      curArr = exceptions;\n      cur = null;\n      return this;\n    }\n  };\n};","/home/travis/build/npmtest/node-npmtest-later/node_modules/later/src/parse/text.js":"/**\n* Parses an English string expression and produces a schedule that is\n* compatible with Later.js.\n*\n* Examples:\n*\n* every 5 minutes between the 1st and 30th minute\n* at 10:00 am on tues of may in 2012\n* on the 15-20th day of march-dec\n* every 20 seconds every 5 minutes every 4 hours between the 10th and 20th hour\n*/\nlater.parse.text = function(str) {\n\n  var recur = later.parse.recur,\n      pos = 0,\n      input = '',\n      error;\n\n  // Regex expressions for all of the valid tokens\n  var TOKENTYPES = {\n        eof: /^$/,\n        rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,\n        time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,\n        dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,\n        monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,\n        yearIndex: /^(\\d\\d\\d\\d)\\b/,\n        every: /^every\\b/,\n        after: /^after\\b/,\n        before: /^before\\b/,\n        second: /^(s|sec(ond)?(s)?)\\b/,\n        minute: /^(m|min(ute)?(s)?)\\b/,\n        hour: /^(h|hour(s)?)\\b/,\n        day: /^(day(s)?( of the month)?)\\b/,\n        dayInstance: /^day instance\\b/,\n        dayOfWeek: /^day(s)? of the week\\b/,\n        dayOfYear: /^day(s)? of the year\\b/,\n        weekOfYear: /^week(s)?( of the year)?\\b/,\n        weekOfMonth: /^week(s)? of the month\\b/,\n        weekday: /^weekday\\b/,\n        weekend: /^weekend\\b/,\n        month: /^month(s)?\\b/,\n        year: /^year(s)?\\b/,\n        between: /^between (the)?\\b/,\n        start: /^(start(ing)? (at|on( the)?)?)\\b/,\n        at: /^(at|@)\\b/,\n        and: /^(,|and\\b)/,\n        except: /^(except\\b)/,\n        also: /(also)\\b/,\n        first: /^(first)\\b/,\n        last: /^last\\b/,\n        \"in\": /^in\\b/,\n        of: /^of\\b/,\n        onthe: /^on the\\b/,\n        on: /^on\\b/,\n        through: /(-|^(to|through)\\b)/\n      };\n\n  // Array to convert string names to valid numerical values\n  var NAMES = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7,\n        aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3,\n        wed: 4, thu: 5, fri: 6, sat: 7, '1st': 1, fir: 1, '2nd': 2, sec: 2,\n        '3rd': 3, thi: 3, '4th': 4, 'for': 4\n      };\n\n  /**\n  * Bundles up the results of the peek operation into a token.\n  *\n  * @param {Int} start: The start position of the token\n  * @param {Int} end: The end position of the token\n  * @param {String} text: The actual text that was parsed\n  * @param {TokenType} type: The TokenType of the token\n  */\n  function t(start, end, text, type) {\n    return {startPos: start, endPos: end, text: text, type: type};\n  }\n\n  /**\n  * Peeks forward to see if the next token is the expected token and\n  * returns the token if found.  Pos is not moved during a Peek operation.\n  *\n  * @param {TokenType} exepected: The types of token to scan for\n  */\n  function peek(expected) {\n    var scanTokens = expected instanceof Array ? expected : [expected],\n        whiteSpace = /\\s+/,\n        token, curInput, m, scanToken, start, len;\n\n    scanTokens.push(whiteSpace);\n\n    // loop past any skipped tokens and only look for expected tokens\n    start = pos;\n    while (!token || token.type === whiteSpace) {\n      len = -1;\n      curInput = input.substring(start);\n      token = t(start, start, input.split(whiteSpace)[0]);\n\n      var i, length = scanTokens.length;\n      for(i = 0; i < length; i++) {\n        scanToken = scanTokens[i];\n        m = scanToken.exec(curInput);\n        if (m && m.index === 0 && m[0].length > len) {\n          len = m[0].length;\n          token = t(start, start + len, curInput.substring(0, len), scanToken);\n        }\n      }\n\n      // update the start position if this token should be skipped\n      if (token.type === whiteSpace) {\n        start = token.endPos;\n      }\n    }\n\n    return token;\n  }\n\n  /**\n  * Moves pos to the end of the expectedToken if it is found.\n  *\n  * @param {TokenType} exepectedToken: The types of token to scan for\n  */\n  function scan(expectedToken) {\n    var token = peek(expectedToken);\n    pos = token.endPos;\n    return token;\n  }\n\n  /**\n  * Parses the next 'y-z' expression and returns the resulting valid\n  * value array.\n  *\n  * @param {TokenType} tokenType: The type of range values allowed\n  */\n  function parseThroughExpr(tokenType) {\n    var start = +parseTokenValue(tokenType),\n        end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start,\n        nums = [];\n\n    for (var i = start; i <= end; i++) {\n      nums.push(i);\n    }\n\n    return nums;\n  }\n\n  /**\n  * Parses the next 'x,y-z' expression and returns the resulting valid\n  * value array.\n  *\n  * @param {TokenType} tokenType: The type of range values allowed\n  */\n  function parseRanges(tokenType) {\n    var nums = parseThroughExpr(tokenType);\n    while (checkAndParse(TOKENTYPES.and)) {\n      nums = nums.concat(parseThroughExpr(tokenType));\n    }\n    return nums;\n  }\n\n  /**\n  * Parses the next 'every (weekend|weekday|x) (starting on|between)' expression.\n  *\n  * @param {Recur} r: The recurrence to add the expression to\n  */\n  function parseEvery(r) {\n    var num, period, start, end;\n\n    if (checkAndParse(TOKENTYPES.weekend)) {\n      r.on(NAMES.sun,NAMES.sat).dayOfWeek();\n    }\n    else if (checkAndParse(TOKENTYPES.weekday)) {\n      r.on(NAMES.mon,NAMES.tue,NAMES.wed,NAMES.thu,NAMES.fri).dayOfWeek();\n    }\n    else {\n      num = parseTokenValue(TOKENTYPES.rank);\n      r.every(num);\n      period = parseTimePeriod(r);\n\n      if (checkAndParse(TOKENTYPES.start)) {\n        num = parseTokenValue(TOKENTYPES.rank);\n        r.startingOn(num);\n        parseToken(period.type);\n      }\n      else if (checkAndParse(TOKENTYPES.between)) {\n        start = parseTokenValue(TOKENTYPES.rank);\n        if (checkAndParse(TOKENTYPES.and)) {\n          end = parseTokenValue(TOKENTYPES.rank);\n          r.between(start,end);\n        }\n      }\n    }\n  }\n\n  /**\n  * Parses the next 'on the (first|last|x,y-z)' expression.\n  *\n  * @param {Recur} r: The recurrence to add the expression to\n  */\n  function parseOnThe(r) {\n    if (checkAndParse(TOKENTYPES.first)) {\n      r.first();\n    }\n    else if (checkAndParse(TOKENTYPES.last)) {\n      r.last();\n    }\n    else {\n      r.on(parseRanges(TOKENTYPES.rank));\n    }\n\n    parseTimePeriod(r);\n  }\n\n  /**\n  * Parses the schedule expression and returns the resulting schedules,\n  * and exceptions.  Error will return the position in the string where\n  * an error occurred, will be null if no errors were found in the\n  * expression.\n  *\n  * @param {String} str: The schedule expression to parse\n  */\n  function parseScheduleExpr(str) {\n    pos = 0;\n    input = str;\n    error = -1;\n\n    var r = recur();\n    while (pos < input.length && error < 0) {\n\n      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before,\n            TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"],\n            TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except,\n            TOKENTYPES.also]);\n\n      switch (token.type) {\n        case TOKENTYPES.every:\n          parseEvery(r);\n          break;\n        case TOKENTYPES.after:\n          if(peek(TOKENTYPES.time).type !== undefined) {\n            r.after(parseTokenValue(TOKENTYPES.time));\n            r.time();\n          }\n          else {\n            r.after(parseTokenValue(TOKENTYPES.rank));\n            parseTimePeriod(r);\n          }\n          break;\n        case TOKENTYPES.before:\n          if(peek(TOKENTYPES.time).type !== undefined) {\n            r.before(parseTokenValue(TOKENTYPES.time));\n            r.time();\n          }\n          else {\n            r.before(parseTokenValue(TOKENTYPES.rank));\n            parseTimePeriod(r);\n          }\n          break;\n        case TOKENTYPES.onthe:\n          parseOnThe(r);\n          break;\n        case TOKENTYPES.on:\n          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();\n          break;\n        case TOKENTYPES.of:\n          r.on(parseRanges(TOKENTYPES.monthName)).month();\n          break;\n        case TOKENTYPES[\"in\"]:\n          r.on(parseRanges(TOKENTYPES.yearIndex)).year();\n          break;\n        case TOKENTYPES.at:\n          r.on(parseTokenValue(TOKENTYPES.time)).time();\n          while (checkAndParse(TOKENTYPES.and)) {\n            r.on(parseTokenValue(TOKENTYPES.time)).time();\n          }\n          break;\n        case TOKENTYPES.and:\n          break;\n        case TOKENTYPES.also:\n          r.and();\n          break;\n        case TOKENTYPES.except:\n          r.except();\n          break;\n        default:\n          error = pos;\n      }\n    }\n\n    return {schedules: r.schedules, exceptions: r.exceptions, error: error};\n  }\n\n  /**\n  * Parses the next token representing a time period and adds it to\n  * the provided recur object.\n  *\n  * @param {Recur} r: The recurrence to add the time period to\n  */\n  function parseTimePeriod(r) {\n    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute,\n          TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek,\n          TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month,\n          TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);\n\n    switch (timePeriod.type) {\n      case TOKENTYPES.second:\n        r.second();\n        break;\n      case TOKENTYPES.minute:\n        r.minute();\n        break;\n      case TOKENTYPES.hour:\n        r.hour();\n        break;\n      case TOKENTYPES.dayOfYear:\n        r.dayOfYear();\n        break;\n      case TOKENTYPES.dayOfWeek:\n        r.dayOfWeek();\n        break;\n      case TOKENTYPES.dayInstance:\n        r.dayOfWeekCount();\n        break;\n      case TOKENTYPES.day:\n        r.dayOfMonth();\n        break;\n      case TOKENTYPES.weekOfMonth:\n        r.weekOfMonth();\n        break;\n      case TOKENTYPES.weekOfYear:\n        r.weekOfYear();\n        break;\n      case TOKENTYPES.month:\n        r.month();\n        break;\n      case TOKENTYPES.year:\n        r.year();\n        break;\n      default:\n        error = pos;\n    }\n\n    return timePeriod;\n  }\n\n  /**\n  * Checks the next token to see if it is of tokenType. Returns true if\n  * it is and discards the token.  Returns false otherwise.\n  *\n  * @param {TokenType} tokenType: The type or types of token to parse\n  */\n  function checkAndParse(tokenType) {\n    var found = (peek(tokenType)).type === tokenType;\n    if (found) {\n      scan(tokenType);\n    }\n    return found;\n  }\n\n  /**\n  * Parses and returns the next token.\n  *\n  * @param {TokenType} tokenType: The type or types of token to parse\n  */\n  function parseToken(tokenType) {\n    var t = scan(tokenType);\n    if (t.type) {\n      t.text = convertString(t.text, tokenType);\n    }\n    else {\n      error = pos;\n    }\n    return t;\n  }\n\n  /**\n  * Returns the text value of the token that was parsed.\n  *\n  * @param {TokenType} tokenType: The type of token to parse\n  */\n  function parseTokenValue(tokenType) {\n    return (parseToken(tokenType)).text;\n  }\n\n  /**\n  * Converts a string value to a numerical value based on the type of\n  * token that was parsed.\n  *\n  * @param {String} str: The schedule string to parse\n  * @param {TokenType} tokenType: The type of token to convert\n  */\n  function convertString(str, tokenType) {\n    var output = str;\n\n    switch (tokenType) {\n      case TOKENTYPES.time:\n        var parts = str.split(/(:|am|pm)/),\n            hour = parts[3] === 'pm' && parts[0] < 12 ? parseInt(parts[0],10) + 12 : parts[0],\n            min = parts[2].trim();\n\n        output = (hour.length === 1 ? '0' : '') + hour + \":\" + min;\n        break;\n\n      case TOKENTYPES.rank:\n        output = parseInt((/^\\d+/.exec(str))[0],10);\n        break;\n\n      case TOKENTYPES.monthName:\n      case TOKENTYPES.dayName:\n        output = NAMES[str.substring(0,3)];\n        break;\n    }\n\n    return output;\n  }\n\n  return parseScheduleExpr(str.toLowerCase());\n};"}